<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>清空（擦除）缓冲区并关闭输出缓冲</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.ob-clean.html">? ob_clean</a></li>
      <li style="float: right;"><a href="function.ob-end-flush.html">ob_end_flush ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.outcontrol.html">输出控制 函数</a></li>
    <li>清空（擦除）缓冲区并关闭输出缓冲</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.ob-end-clean" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">ob_end_clean</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">ob_end_clean</span> &mdash; <span class="dc-title">清空（擦除）缓冲区并关闭输出缓冲</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.ob-end-clean-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>ob_end_clean</strong></span>(): <span class="type">bool</span></div>

  <p class="para rdfs-comment">
   此函数丢弃最顶层输出缓冲区的内容并关闭这个缓冲区。如果想要进一步处理缓冲区的内容，必须在
   <span class="function"><strong>ob_end_clean()</strong></span> 之前调用 <span class="function"><a href="function.ob-get-contents.html" class="function">ob_get_contents()</a></span>，因为当调用
   <span class="function"><strong>ob_end_clean()</strong></span> 时缓冲区内容将被丢弃。
  </p>
  <p class="para">
   输出缓冲区必须由带有 <a href="outcontrol.constants.html#constant.php-output-handler-cleanable" class="link">PHP_OUTPUT_HANDLER_CLEANABLE</a>
   和 <a href="outcontrol.constants.html#constant.php-output-handler-removable" class="link">PHP_OUTPUT_HANDLER_REMOVABLE</a> flag
   的 <span class="function"><a href="function.ob-start.html" class="function">ob_start()</a></span> 启动。否则 <span class="function"><strong>ob_end_clean()</strong></span> 将不起作用。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.ob-end-clean-parameters">
  <h3 class="title">参数</h3>
  <p class="para">此函数没有参数。</p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.ob-end-clean-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   成功时返回 <strong><code>true</code></strong>， 或者在失败时返回 <strong><code>false</code></strong>。 错误的原因首先是，在调用时没有一个起作用的缓冲区，或者是因为某些原因缓冲区不能被删除（可能对特殊缓冲区而言）。   
  </p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.ob-end-clean-errors">
  <h3 class="title">错误／异常</h3>
  <p class="para">
  如果函数失败了，将引发一个<strong><code>E_NOTICE</code></strong>异常。
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.ob-end-clean-examples">
  <h3 class="title">示例</h3>
  <p class="para">
  下面的例子给出了一种去除所有输出缓冲区的方法：   
  </p>
  <p class="para">
   <div class="example" id="example-1070">
    <p><strong>Example #1 <span class="function"><strong>ob_end_clean()</strong></span> 示例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />ob_start</span><span style="color: #007700">();<br />echo </span><span style="color: #DD0000">'Text that won\'t get displayed.'</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">ob_end_clean</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.ob-end-clean-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.ob-start.html" class="function" rel="rdfs-seeAlso">ob_start()</a> - 打开输出控制缓冲</span></li>
    <li class="member"><span class="function"><a href="function.ob-get-contents.html" class="function" rel="rdfs-seeAlso">ob_get_contents()</a> - 返回输出缓冲区的内容</span></li>
    <li class="member"><span class="function"><a href="function.ob-flush.html" class="function" rel="rdfs-seeAlso">ob_flush()</a> - 冲刷出（送出）输出缓冲区中的内容</span></li>
   </ul>
  </p>
 </div>
 

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="124936""></a>
  <div class="note">
   <strong class="user">baklanoid at gmail dot com</strong>
   <a href="#124936" class="date">23-Apr-2020 09:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If there is no confidence about output buffering (enabled or not),<br />
you may try these guards:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">while (</span><span class="default">ob_get_level</span><span class="keyword">() !== </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">ob_end_clean</span><span class="keyword">();<br />
}<br />
<br />
</span><span class="comment">// or<br />
<br />
</span><span class="keyword">while (</span><span class="default">ob_get_length</span><span class="keyword">() !== </span><span class="default">false</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">ob_end_clean</span><span class="keyword">();<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="121774""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#121774" class="date">19-Oct-2017 07:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To safely clear and close all non-lethal output buffers:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">ob_end_clean_all</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$handlers </span><span class="keyword">= </span><span class="default">ob_list_handlers</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; while (</span><span class="default">count</span><span class="keyword">(</span><span class="default">$handlers</span><span class="keyword">) &gt; </span><span class="default">0 </span><span class="keyword">&amp;&amp; </span><span class="default">$handlers</span><span class="keyword">[</span><span class="default">count</span><span class="keyword">(</span><span class="default">$handlers</span><span class="keyword">) - </span><span class="default">1</span><span class="keyword">] != </span><span class="string">'ob_gzhandler' </span><span class="keyword">&amp;&amp; </span><span class="default">$handlers</span><span class="keyword">[</span><span class="default">count</span><span class="keyword">(</span><span class="default">$handlers</span><span class="keyword">) - </span><span class="default">1</span><span class="keyword">] != </span><span class="string">'zlib output compression'</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">ob_end_clean</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$handlers </span><span class="keyword">= </span><span class="default">ob_list_handlers</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; }<br />
}</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="103817""></a>
  <div class="note">
   <strong class="user">Sam Yong - hellclanner at live dot com</strong>
   <a href="#103817" class="date">04-May-2011 10:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Take note that if you change zlib output compression setting in between ob_start and ob_end_clean or ob_end_flush, you will get an error: ob_end_flush() failed to delete buffer zlib output compression<br />
<br />
Example:<br />
<br />
<span class="default">&lt;?php<br />
<br />
ob_start</span><span class="keyword">();<br />
<br />
</span><span class="default">$output </span><span class="keyword">= </span><span class="default">ob_get_contents</span><span class="keyword">();<br />
<br />
</span><span class="default">ini_set</span><span class="keyword">(</span><span class="string">'zlib.output_compression'</span><span class="keyword">, </span><span class="string">'1'</span><span class="keyword">);<br />
<br />
</span><span class="default">ob_end_clean</span><span class="keyword">();<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
ob_end_clean(); in this example will throw the error.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95773""></a>
  <div class="note">
   <strong class="user">netom at elte dot hu</strong>
   <a href="#95773" class="date">21-Jan-2010 04:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Notice that ob_end_clean() does discard headers.<br />
<br />
If you would like to clear the output buffer, but not the headers (because you use firephp for example...), than this is the solution:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp; </span><span class="keyword">...<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$headers </span><span class="keyword">= array();<br />
&nbsp;&nbsp;&nbsp; if ( !</span><span class="default">headers_sent</span><span class="keyword">() ) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$headers </span><span class="keyword">= </span><span class="default">apache_response_headers</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_end_clean</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_start</span><span class="keyword">();<br />
<br />
&nbsp;&nbsp;&nbsp; if ( !empty( </span><span class="default">$headers </span><span class="keyword">) ) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; foreach ( </span><span class="default">$headers </span><span class="keyword">as </span><span class="default">$name </span><span class="keyword">=&gt; </span><span class="default">$value </span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">( </span><span class="string">"</span><span class="default">$name</span><span class="string">: </span><span class="default">$value</span><span class="string">" </span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; ...<br />
</span><span class="default">?&gt;<br />
</span><br />
I use it in a general exception handler in a web application, where I clear the buffer (but not the debug-info-containing headers), and send a 500 error page with readfile().<br />
<br />
Good PHPing,<br />
<br />
Tamas.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="85014""></a>
  <div class="note">
   <strong class="user">tyler @</strong>
   <a href="#85014" class="date">10-Aug-2008 04:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In reference to &lt;geoff at spacevs dot com&gt; where he states, "If you call ob_end_clean in a function registered with 'register_shutdown_function', it is too late, any buffers will have already been sent out to the client.", here is a workaround I came up with.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">ClearBuffer</span><span class="keyword">(</span><span class="default">$Buffer</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; return </span><span class="string">""</span><span class="keyword">;<br />
}<br />
<br />
function </span><span class="default">Shutdown</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_start</span><span class="keyword">(</span><span class="string">"ClearBuffer"</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="default">register_shutdown_function</span><span class="keyword">(</span><span class="string">"Shutdown"</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
This will wipe out all the contents of the output buffer as it comes in. Basically its the same as "STDOUT &gt; /dev/null".</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="76609""></a>
  <div class="note">
   <strong class="user">geoff at spacevs dot com</strong>
   <a href="#76609" class="date">22-Jul-2007 05:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you call ob_end_clean in a function registered with "register_shutdown_function", it is too late, any buffers will have already been sent out to the client.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71092""></a>
  <div class="note">
   <strong class="user">everling</strong>
   <a href="#71092" class="date">11-Nov-2006 02:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Keep in mind that mrfritz379's example (#49800) is just an example. You can achieve that example's result in a more efficient manner without using output buffering functions:<br />
<br />
echo "&lt;p&gt;Search running. Please be patient. . .";<br />
$output = "&lt;p&gt;FileList: &lt;/p&gt;\n";<br />
if (is_dir($dir)) {<br />
&nbsp; $dh = opendir($dir);<br />
<br />
&nbsp; while (($fd = readdir($dh)) != false) {<br />
&nbsp;&nbsp;&nbsp; echo " .";<br />
&nbsp;&nbsp;&nbsp; $output .= $fd;<br />
&nbsp; }<br />
}<br />
echo "&lt;/br&gt;Search Complete!&lt;/p&gt;\n";<br />
echo $output;<br />
<br />
&nbsp;<br />
&nbsp;<br />
&nbsp;<br />
<br />
In addition to John Smith's comment (#42939), ob_gzhandler() may still set the HTTP header "Content-Encoding" to "gzip" or "deflate" even if you call ob_end_clean(). This will cause a problem in the following situation:<br />
<br />
1. Call ob_gzhandler().<br />
2. Echo "Some content";<br />
3. Call ob_end_clean().<br />
4. Echo "New content";<br />
<br />
In the above case, the browser may receive the "Content-Encoding: gzip" HTTP header and attempts to decompress the uncompressed "New content". The browser will fail.<br />
<br />
In the following situation, this behaviour will go unnoticed:<br />
<br />
1. Call ob_gzhandler().<br />
2. Echo "Some content";<br />
3. Call ob_end_clean().<br />
4. Call ob_gzhandler().<br />
5. Echo "New content";<br />
<br />
This is because the second ob_gzhandler() will mask the absence of the first ob_gzhandler().<br />
<br />
A solution would be to write a wrapper, like John Smith did, for the ob_gzhandler().</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="66302""></a>
  <div class="note">
   <strong class="user">Adam of Fusion Bay</strong>
   <a href="#66302" class="date">18-May-2006 12:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You may want to be careful about calling ob_end_clean() from within your call-back function. I believe this can produce an endless-loop within PHP.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49800""></a>
  <div class="note">
   <strong class="user">mrfritz379</strong>
   <a href="#49800" class="date">08-Feb-2005 06:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This may be posted elsewhere, but I haven't seen it.<br />
To run a progress indicator while the program is running without outputting the output buffer, the following will work:<br />
<br />
echo "&lt;p&gt;Search running. Please be patient. . .";<br />
$output = "&lt;p&gt;FileList: &lt;/p&gt;\n";<br />
if (is_dir($dir)) {<br />
&nbsp;&nbsp; $dh = opendir($dir);<br />
<br />
&nbsp;&nbsp; while (($fd = readdir($dh)) != false) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; echo " .";<br />
&nbsp;&nbsp; &nbsp;&nbsp; ob_start();<br />
&nbsp;&nbsp; &nbsp;&nbsp; echo $fd;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $output .= ob_get_contents();<br />
&nbsp;&nbsp; &nbsp;&nbsp; ob_end_clean();<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
echo "&lt;/br&gt;Search Complete!&lt;/p&gt;\n";<br />
echo $output;<br />
<br />
The program will continue to print the " ." without printing the file list. Then the "Search Complete" message will print followed by the buffered file list.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42939""></a>
  <div class="note">
   <strong class="user">John Smith</strong>
   <a href="#42939" class="date">04-Jun-2004 04:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that if you started called ob_start with a callback, that callback will still be called even if you discard the OB with ob_end_clean.<br />
<br />
Because there is no way of removing the callback from the OB once you've set it, the only way to stop the callback function from having any effect is to do something like:<br />
<br />
<span class="default">&lt;?php<br />
$ignore_callback </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">;<br />
</span><span class="default">ob_start</span><span class="keyword">(</span><span class="string">'my_callback'</span><span class="keyword">);<br />
...<br />
if(</span><span class="default">$need_to_abort</span><span class="keyword">) {<br />
&nbsp;&nbsp; </span><span class="default">$ignore_callback </span><span class="keyword">= </span><span class="default">true</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">ob_end_clean</span><span class="keyword">();<br />
&nbsp;&nbsp; ...<br />
}<br />
<br />
function </span><span class="default">my_callback</span><span class="keyword">(&amp;</span><span class="default">$buffer</span><span class="keyword">) {<br />
&nbsp; if(</span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="string">'ignore_callback'</span><span class="keyword">]) {<br />
&nbsp;&nbsp; &nbsp; return </span><span class="string">""</span><span class="keyword">;<br />
&nbsp; }<br />
&nbsp; ...<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="40108""></a>
  <div class="note">
   <strong class="user">daijoubuNOSP at Mvideotron dot com</strong>
   <a href="#40108" class="date">22-Feb-2004 01:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
About the previous comment:<br />
You can also relay on ETag and simply use time()<br />
<br />
<span class="default">&lt;?php<br />
$time </span><span class="keyword">= </span><span class="default">time</span><span class="keyword">();<br />
</span><span class="default">$mins </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
if (isset(</span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'HTTP_IF_NONE_MATCH'</span><span class="keyword">]) and </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">'"'</span><span class="keyword">, </span><span class="string">''</span><span class="keyword">, </span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'HTTP_IF_NONE_MATCH'</span><span class="keyword">])+(</span><span class="default">$mins</span><span class="keyword">*</span><span class="default">60</span><span class="keyword">) &gt; </span><span class="default">$time</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">'HTTP/1.1 304 Not Modified'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; exit();<br />
}<br />
else<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">'ETag: "'</span><span class="keyword">.</span><span class="default">$time</span><span class="keyword">.</span><span class="string">'"'</span><span class="keyword">);<br />
}<br />
echo </span><span class="string">'Caching for '</span><span class="keyword">, </span><span class="default">$mins</span><span class="keyword">*</span><span class="default">60</span><span class="keyword">, </span><span class="string">'secs&lt;br/&gt;'</span><span class="keyword">, </span><span class="default">date</span><span class="keyword">(</span><span class="string">'G:i:s'</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="33484""></a>
  <div class="note">
   <strong class="user">programmer at bardware dot de</strong>
   <a href="#33484" class="date">27-Jun-2003 06:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You might want to prevent your script from executing if the client already has the latest version.<br />
You can do it like so:<br />
<br />
ob_start();<br />
<br />
$mtime=filemtime($_SERVER["SCRIPT_FILENAME"])-date("Z");<br />
$gmt_mtime = date('D, d M Y H:i:s', $mtime) . ' GMT';<br />
<br />
$headers = getallheaders();<br />
<br />
if(isset($headers["If-Modified-Since"])) {<br />
&nbsp;&nbsp;&nbsp; if ($headers["If-Modified-Since"] == $gmt_mtime) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; header("HTTP/1.1 304 Not Modified");<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ob_end_clean();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; exit;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
$size=ob_get_length();<br />
header("Last-Modified: ".$gmt_mtime);<br />
header("Content-Length: $size");<br />
ob_end_flush();<br />
<br />
Instead of checking the If-Modified-Since-Header against the date of the last modification of the script, you can of course query a database or take any other date that is somehow related to the modification of the result of your script.<br />
<br />
You can for instance use this technique to generate images dynamically. If the user indicates he already has a version of the image by the If-Modified-Since-Header, there's no need to generate it and let the server finally discard it because the server only then interpretes the If-Modified-Since-Header.<br />
This saves server load and shortens response-times.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
