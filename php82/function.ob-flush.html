<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>冲刷出（送出）输出缓冲区中的内容</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.ob-end-flush.html">? ob_end_flush</a></li>
      <li style="float: right;"><a href="function.ob-get-clean.html">ob_get_clean ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.outcontrol.html">输出控制 函数</a></li>
    <li>冲刷出（送出）输出缓冲区中的内容</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.ob-flush" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">ob_flush</h1>
  <p class="verinfo">(PHP 4 &gt;= 4.2.0, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">ob_flush</span> &mdash; <span class="dc-title">冲刷出（送出）输出缓冲区中的内容</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.ob-flush-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>ob_flush</strong></span>(): <span class="type">bool</span></div>

  <p class="para rdfs-comment">
   这个函数将送出缓冲区的内容（如果里边有内容的话）。如果想进一步处理缓冲区中的内容，必须在<span class="function"><strong>ob_flush()</strong></span>之前调用<span class="function"><a href="function.ob-get-contents.html" class="function">ob_get_contents()</a></span> ，因为在调用<span class="function"><strong>ob_flush()</strong></span>之后缓冲区内容将被丢弃。
  </p>
  <p class="para">
  此函数不会销毁输出缓冲区，而像<span class="function"><a href="function.ob-end-flush.html" class="function">ob_end_flush()</a></span> 函数会销毁缓冲区。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.ob-flush-parameters">
  <h3 class="title">参数</h3>
  <p class="para">此函数没有参数。</p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.ob-flush-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   成功时返回 <strong><code>true</code></strong>， 或者在失败时返回 <strong><code>false</code></strong>。
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.ob-flush-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.ob-get-contents.html" class="function" rel="rdfs-seeAlso">ob_get_contents()</a> - 返回输出缓冲区的内容</span></li>
    <li class="member"><span class="function"><a href="function.ob-clean.html" class="function" rel="rdfs-seeAlso">ob_clean()</a> - 清空（擦掉）输出缓冲区</span></li>
    <li class="member"><span class="function"><a href="function.ob-end-flush.html" class="function" rel="rdfs-seeAlso">ob_end_flush()</a> - 冲刷出（送出）输出缓冲区内容并关闭缓冲区</span></li>
    <li class="member"><span class="function"><a href="function.ob-end-clean.html" class="function" rel="rdfs-seeAlso">ob_end_clean()</a> - 清空（擦除）缓冲区并关闭输出缓冲</span></li>
   </ul>
  </p>
 </div>
 

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="123228""></a>
  <div class="note">
   <strong class="user">jake at qzdesign dot co dot uk</strong>
   <a href="#123228" class="date">12-Oct-2018 11:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If there is no active output buffer, an error of level E_NOTICE is generated (at least in PHP 7.1).&nbsp; To avoid this, test first with `ob_get_level()`.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="117850""></a>
  <div class="note">
   <strong class="user">chris - latko - org</strong>
   <a href="#117850" class="date">19-Aug-2015 10:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Although browsers now have an all or none buffering strategy, the arguments are not moot.<br />
<br />
If you are not using ob_flush, you run this risk of exceeding socket timeouts (commonly seen in php-fpm/nginx combos).<br />
<br />
Basically, flushing solves the infamous 504 Gateway Time-out error.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111619""></a>
  <div class="note">
   <strong class="user">cesoid at gmail dot com</strong>
   <a href="#111619" class="date">08-Mar-2013 08:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Currently I have Chrome on OS X Snow Leopard updating a page as it is sent more data, BUT it only does this after I send it &lt;body&gt; along with 1013 more characters (making 1019 total characters). After it receives this it immediately displays it and then displays anything else as it is received. (Note that this browser-operating system combination isn't necessarily the only one, it's just the only one I've tested.)<br />
<br />
In order to do this using php, I've done nothing but send ob_flush() after each echo or print. I can also make it happen without ob_flush() by calling ob_implicit_flush(), then ob_end_flush() before print, and then it updates with each print after that. I have pretty typical settings and I change none of them when the file runs, it literally looks like this:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; ob_implicit_flush</span><span class="keyword">();<br />
&nbsp; </span><span class="default">ob_end_flush</span><span class="keyword">();<br />
&nbsp; </span><span class="default">?&gt;</span>&lt;body&gt;[1013 more characters]<span class="default">&lt;?php<br />
&nbsp; </span><span class="keyword">for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">30000000</span><span class="keyword">; ++</span><span class="default">$i</span><span class="keyword">) {}<br />
&nbsp; echo </span><span class="string">"something that didn't show up immediately"</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
(Ok, the "[1013 more characters]" part wasn't strictly literal.)<br />
<br />
If you want just text in the browser, you do this before everything else:<br />
<br />
<span class="default">&lt;?php<br />
header</span><span class="keyword">(</span><span class="string">"Content-type: text/plain"</span><span class="keyword">);<br />
...<br />
</span><span class="default">?&gt;<br />
</span><br />
Then it won't care whether you sent a body tag, it will just wait for 1019 characters.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="109699""></a>
  <div class="note">
   <strong class="user">Lee</strong>
   <a href="#109699" class="date">11-Aug-2012 11:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As of August 2012, all browsers seem to show an all-or-nothing approach to buffering. In other words, while php is operating, no content can be shown.<br />
<br />
In particular this means that the following workarounds listed further down here are ineffective:<br />
<br />
1) ob_flush (),&nbsp; flush () in any combination with other output buffering functions;<br />
<br />
2) changes to php.ini involving setting output_buffer and/or zlib.output_compression to 0 or Off;<br />
<br />
3) setting Apache variables such as "no-gzip" either through apache_setenv () or through entries in .htaccess.<br />
<br />
So, until browsers begin to show buffered content again, the tips listed here are moot.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="109314""></a>
  <div class="note">
   <strong class="user">dermeister dot online at gmail dot com</strong>
   <a href="#109314" class="date">05-Jul-2012 01:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
some problems with ob_flush() and flush() could be resolved by defining content type header :<br />
header( 'Content-type: text/html; CHARSET=gb2312' );<br />
<br />
so working code looks like this:<br />
<span class="default">&lt;?php<br />
header</span><span class="keyword">( </span><span class="string">'Content-type: text/html; CHARSET=gb2312' </span><span class="keyword">);<br />
echo </span><span class="string">'Begin ...&lt;br /&gt;'</span><span class="keyword">;<br />
for( </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0 </span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">10 </span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++ )<br />
{<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$i </span><span class="keyword">. </span><span class="string">'&lt;br /&gt;'</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">flush</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_flush</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">1</span><span class="keyword">);<br />
}<br />
echo </span><span class="string">'End ...&lt;br /&gt;'</span><span class="keyword">;<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100462""></a>
  <div class="note">
   <strong class="user">riimeik</strong>
   <a href="#100462" class="date">17-Oct-2010 01:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you're still not getting the buffer work correctly then try to clean all the others before starting your own (and even if PHP tells you that there are no buffers active):<br />
<br />
while(@ob_end_clean());</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90529""></a>
  <div class="note">
   <strong class="user">sebastian at jcompare dot com</strong>
   <a href="#90529" class="date">26-Apr-2009 07:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For some reason, calling just flush or ob_flush or even both together did not get my output buffers flushed, and calling ob_end_flush by itself didn't work either but calling them all worked well. Here is my new output flushing function.
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">flush_buffers</span><span class="keyword">(){
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_end_flush</span><span class="keyword">();
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_flush</span><span class="keyword">();
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">flush</span><span class="keyword">();
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_start</span><span class="keyword">();
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
Enjoy</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="86692""></a>
  <div class="note">
   <strong class="user">Jens</strong>
   <a href="#86692" class="date">29-Oct-2008 07:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you call ob_flush() and flush() and still dont get the buffer flushed it might be because some antivirus software (Panda in this case) holds the buffer until the page has finished loaded before sending it to the browser.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84297""></a>
  <div class="note">
   <strong class="user">colnector at@ colnect punto com</strong>
   <a href="#84297" class="date">08-Jul-2008 04:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As stated in flush() manual entry, if php compresses the ouput with zlib this function may be ineffective.<br />
<br />
A possible option for folders on your server that have scripts which may take a long time to run is to add the following in your relevant .htaccess file:<br />
<br />
&lt;FilesMatch "\.(php|html?)$"&gt;<br />
php_flag zlib.output_compression off<br />
php_value max_execution_time 3000<br />
php_value max_input_time 3000<br />
&lt;/FilesMatch&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83652""></a>
  <div class="note">
   <strong class="user">kel at no-spam dot newcastleinfotech dot com dot au</strong>
   <a href="#83652" class="date">05-Jun-2008 09:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Also note that any data in the buffer will flush at the end of the script, not destroyed, so it is often not necessary to call ob_flush(); for example:<br />
<br />
<span class="default">&lt;?php<br />
ob_start</span><span class="keyword">();<br />
echo </span><span class="string">'Hello World!'<br />
</span><span class="default">?&gt;<br />
</span><br />
Will still result in Hello World! being displayed to the browser.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57030""></a>
  <div class="note">
   
   <a href="#57030" class="date">21-Sep-2005 06:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I was having problems with output buffering which seemed to be active by default on the server, although phpinfo said something else..<br />
<br />
In any case I needed to know that when I ran ob_start, it would start at the top level, so I could use ob_flush as it's intended without having to call multiple ob_flush in-script - this is what I did:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// make sure output buffering is off before we start it<br />
// this will ensure same effect whether or not ob is enabled already<br />
</span><span class="keyword">while (</span><span class="default">ob_get_level</span><span class="keyword">()) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_end_flush</span><span class="keyword">();<br />
}<br />
</span><span class="comment">// start output buffering<br />
</span><span class="keyword">if (</span><span class="default">ob_get_length</span><span class="keyword">() === </span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_start</span><span class="keyword">();<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Then I could call ob_flush(); followed by flush(); and get the output I wanted, which I didn't if I started the script with just ob_start();<br />
<br />
This was on a windows apache 2 server with php 5.0.4 btw.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="54126""></a>
  <div class="note">
   
   <a href="#54126" class="date">24-Jun-2005 06:27</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You must call them in the correct order.<br />
ob_flush();<br />
flush();</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="54068""></a>
  <div class="note">
   <strong class="user">Reynard Hilman</strong>
   <a href="#54068" class="date">22-Jun-2005 02:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
when using command line php, if somewhere in your script you have ob_start(), you have to call ob_end_flush() first, and then you can call these functions: <br />
flush();<br />
ob_flush();<br />
<br />
without calling ob_end_flush first, flush and ob_flush does not have any effect, at least that's what I experienced.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="53211""></a>
  <div class="note">
   <strong class="user">jeremy at e2-media dot co dot nz</strong>
   <a href="#53211" class="date">25-May-2005 04:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
we had problems with flushing data to the browser. a simple call to ob_flush() or flush() would not work. We found that repeatly calling theses fuctions did work however.<br />
<br />
&lt;?<br />
flush();<br />
ob_flush();<br />
flush();<br />
ob_flush();<br />
flush();<br />
ob_flush();<br />
?&gt;<br />
<br />
go figure!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
