<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>模式修饰符</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="regexp.reference.performance.html">? 性能</a></li>
      <li style="float: right;"><a href="reference.pcre.pattern.differences.html">与 perl 的不同之处 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="pcre.pattern.html">PCRE模式</a></li>
    <li>模式修饰符</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="reference.pcre.pattern.modifiers" class="article">
 <h1>模式修饰符</h1>

 
  <p class="para">
  下面列出了当前可用的 PCRE 修饰符。括号中提到的名字是 PCRE 内部这些修饰符的名称。
  模式修饰符中的空格，换行符会被忽略，其他字符会导致错误。
  </p>
  <p class="para">
   <blockquote class="blockquote">
    <dl>
     
      <dt>
<em class="emphasis">i</em> (<code class="literal">PCRE_CASELESS</code>)</dt>

      <dd>

       <span class="simpara">
       如果设置了这个修饰符，模式中的字母会进行大小写不敏感匹配。
       </span>
      </dd>

     
     
      <dt>
<em class="emphasis">m</em> (<code class="literal">PCRE_MULTILINE</code>)</dt>

      <dd>

       <span class="simpara">
       默认情况下，PCRE 认为目标字符串是由单行字符组成的(然而实际上它可能会包含多行)，
   &quot;行首&quot;元字符 (^) 仅匹配字符串的开始位置， 而&quot;行末&quot;元字符 ($) 仅匹配字符串末尾，
   或者最后的换行符(除非设置了 <em class="emphasis">D</em> 修饰符)。这个行为和 perl 相同。
       </span>
       <span class="simpara">
       当这个修饰符设置之后，"行首"和"行末"就会匹配目标字符串中任意换行符之前或之后，另外，
       还分别匹配目标字符串的最开始和最末尾位置。这等同于 perl 的 /m 修饰符。如果目标字符串
       中没有 &quot;\n&quot; 字符，或者模式中没有出现 ^ 或 $，设置这个修饰符不产生任何影响。
       </span>
      </dd>

     
     
      <dt>
<em class="emphasis">s</em> (<code class="literal">PCRE_DOTALL</code>)</dt>

      <dd>

       <span class="simpara">
       如果设置了这个修饰符，模式中的点号元字符匹配所有字符，包含换行符。如果没有这个
       修饰符，点号不匹配换行符。这个修饰符等同于 perl 中的/s修饰符。 一个取反字符类比如
       [^a] 总是匹配换行符，而不依赖于这个修饰符的设置。
       </span>
      </dd>

     
     
      <dt>
<em class="emphasis">x</em> (<code class="literal">PCRE_EXTENDED</code>)</dt>

      <dd>

       <span class="simpara">
       如果设置了这个修饰符，模式中的没有经过转义的或不在字符类中的空白数据字符总会被忽略， 
       并且位于一个未转义的字符类外部的#字符和下一个换行符之间的字符也被忽略。
        这个修饰符
       等同于 perl 中的 /x 修饰符，使被编译模式中可以包含注释。 注意：这仅用于数据字符。 空白字符
       还是不能在模式的特殊字符序列中出现，比如序列 (?( 引入了一个条件子组(译注: 这种语法定义的
       特殊字符序列中如果出现空白字符会导致编译错误。 比如(?(就会导致错误)。
       </span>
      </dd>

     
     
      <dt>
<em class="emphasis">A</em> (<code class="literal">PCRE_ANCHORED</code>)</dt>

      <dd>

       <span class="simpara">
       如果设置了这个修饰符，模式被强制为&quot;锚定&quot;模式，也就是说约束匹配使其仅从
       目标字符串的开始位置搜索。这个效果同样可以使用适当的模式构造出来，并且
       这也是 perl 种实现这种模式的唯一途径。
       </span>
      </dd>

     
     
      <dt>
<em class="emphasis">D</em> (<code class="literal">PCRE_DOLLAR_ENDONLY</code>)</dt>

      <dd>

       <span class="simpara">
       如果这个修饰符被设置，模式中的元字符美元符号仅仅匹配目标字符串的末尾。如果这个修饰符
       没有设置，当字符串以一个换行符结尾时， 美元符号还会匹配该换行符(但不会匹配之前的任何换行符)。
   如果设置了修饰符<em class="emphasis">m</em>，这个修饰符被忽略. 在 perl 中没有与此修饰符等同的修饰符。
       </span>
      </dd>

     
     
      <dt>
<em class="emphasis">S</em></dt>

      <dd>

       <span class="simpara">
       当一个模式需要多次使用的时候，为了得到匹配速度的提升，值得花费一些时间
       对其进行一些额外的分析。如果设置了这个修饰符，这个额外的分析就会执行。当前， 
       这种对一个模式的分析仅仅适用于非锚定模式的匹配(即没有单独的固定开始字符)。
       </span>
      </dd>

     
     
      <dt>
<em class="emphasis">U</em> (<code class="literal">PCRE_UNGREEDY</code>)</dt>

      <dd>

       <span class="simpara">
       这个修饰符逆转了量词的&quot;贪婪&quot;模式。 使量词默认为非贪婪的，通过量词后紧跟<code class="literal">?</code>
       的方式可以使其成为贪婪的。这和 perl 是不兼容的。 它同样可以使用
       <a href="regexp.reference.internal-options.html" class="link">模式内修饰符设置</a>
       (<code class="literal">?U</code>)进行设置， 或者在量词后以问号标记其非贪婪(比如<code class="literal">.*?</code>)。
       </span>
       <blockquote class="note"><p><strong class="note">Note</strong>: 
        <p class="para">
        在非贪婪模式，通常不能匹配超过
        <a href="pcre.configuration.html#ini.pcre.backtrack-limit" class="link">pcre.backtrack_limit</a>
        的字符。
        </p>
       </p></blockquote>
      </dd>

     
     
      <dt>
<em class="emphasis">X</em> (<code class="literal">PCRE_EXTRA</code>)</dt>

      <dd>

       <span class="simpara">
       这个修饰符打开了 PCRE 与 perl 不兼容的附件功能。模式中的任意反斜线后就 ingen 一个
       没有特殊含义的字符都会导致一个错误，以此保留这些字符以保证向后兼容性。
        默认情况下，在 perl 中，反斜线紧跟一个没有特殊含义的字符被认为是该字符的原文。
       当前没有其他特性由这个修饰符控制。
       </span>
      </dd>

     
     
      <dt>
<em class="emphasis">J</em> (<code class="literal">PCRE_INFO_JCHANGED</code>)</dt>

      <dd>

       <span class="simpara">
       内部选项设置(?J)修改本地的<code class="literal">PCRE_DUPNAMES</code>选项。允许子组重名，
       (译注：只能通过内部选项设置，外部的 /J 设置会产生错误。)
       自 PHP 7.2.0 起，也能支持 <code class="literal">J</code> 修饰符。
       </span>
      </dd>

     
     
      <dt>
<em class="emphasis">u</em> (<code class="literal">PCRE_UTF8</code>)</dt>

      <dd>

       <span class="simpara">
       此修正符打开一个与 Perl 不兼容的附加功能。 模式和目标字符串都被认为是 UTF-8 的。
        无效的目标字符串会导致 preg_* 函数什么都匹配不到；
        无效的模式字符串会导致 E_WARNING 级别的错误。
        5 字节和 6 字节的 UTF-8 字符序列以无效字符序列对待。
       </span>
      </dd>

     
    </dl>

   </blockquote>
  </p>
</div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="125154""></a>
  <div class="note">
   <strong class="user">Hayley Watson</strong>
   <a href="#125154" class="date">30-Jun-2020 01:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Starting from 7.3.0, the 'S' modifier has no effect; this analysis is now always done by the PCRE engine.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="124057""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#124057" class="date">22-Jul-2019 12:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A warning about the /i modifier and POSIX character classes:<br />
If you're using POSIX character classes in your regex that indicate case such as [:upper:] or [:lower:] in combination with the /i modifier, then in PHP &lt; 7.3 the /i modifier will take precedence and effectively make both those character classes work as [:alpha:], but in PHP &gt;= 7.3 the character classes overrule the /i modifier.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="122429""></a>
  <div class="note">
   <strong class="user">Wirek</strong>
   <a href="#122429" class="date">23-Feb-2018 12:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
An important addendum (with new $pat3_2 utilising \R properly, its results and comments):<br />
Note that there are (sometimes difficult to grasp at first glance) nuances of meaning and application of escape sequences like \r, \R and \v - none of them is perfect in all situations, but they are quite useful nevertheless. Some official PCRE control options and their changes come in handy too - unfortunately neither (*ANYCRLF), (*ANY) nor (*CRLF) is documented here on php.net at the moment (although they seem to be available for over 10 years and 5 months now), but they are described on Wikipedia ("Newline/linebreak options" at https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions) and official PCRE library site ("Newline convention" at <a href="http://www.pcre.org/original/doc/html/pcresyntax.html#SEC17" rel="nofollow" target="_blank">http://www.pcre.org/original/doc/html/pcresyntax.html#SEC17</a>) pretty well. The functionality of \R appears somehow disappointing (with default configuration of compile time option) according to php.net as well as official description ("Newline sequences" at https://www.pcre.org/original/doc/html/pcrepattern.html#newlineseq) when used improperly.<br />
<br />
A hint for those of you who are trying to fight off (or work around at least) the problem of matching a pattern correctly at the end (or at the beginning) of any line even without the multiple lines mode (/m) or meta-character assertions ($ or ^).<br />
<span class="default">&lt;?php <br />
</span><span class="comment">// Various OS-es have various end line (a.k.a line break) chars:<br />
// - Windows uses CR+LF (\r\n);<br />
// - Linux LF (\n);<br />
// - OSX CR (\r).<br />
// And that's why single dollar meta assertion ($) sometimes fails with multiline modifier (/m) mode - possible bug in PHP 5.3.8 or just a "feature"(?) of default configuration option for meta-character assertions (^ and $) at compile time of PCRE.<br />
</span><span class="default">$str</span><span class="keyword">=</span><span class="string">"ABC ABC\n\n123 123\r\ndef def\rnop nop\r\n890 890\nQRS QRS\r\r~-_ ~-_"</span><span class="keyword">;<br />
</span><span class="comment">//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; p&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; _<br />
</span><span class="default">$pat3</span><span class="keyword">=</span><span class="string">'/\w\R?$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Somehow disappointing according to php.net and pcre.org when used improperly<br />
</span><span class="default">$pat3_2</span><span class="keyword">=</span><span class="string">'/\w(?=\R)/i'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Much better with allowed lookahead assertion (just to detect without capture) without multiline (/m) mode; note that with alternative for end of string ((?=\R|$)) it would grab all 7 elements as expected, but '/(*ANYCRLF)\w$/mi' is more straightforward in use anyway<br />
</span><span class="default">$p</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat3</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m3</span><span class="keyword">);<br />
</span><span class="default">$r</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat3_2</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m4</span><span class="keyword">);<br />
echo </span><span class="default">$str</span><span class="keyword">.</span><span class="string">"\n3 !!! </span><span class="default">$pat3</span><span class="string"> (</span><span class="default">$p</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m3</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n3_2 !!! </span><span class="default">$pat3_2</span><span class="string"> (</span><span class="default">$r</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m4</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">);<br />
</span><span class="comment">// Note the difference between the two very helpful escape sequences in $pat3 and $pat3_2 (\R) - for some applications at least.<br />
<br />
/* The code above results in the following output:<br />
ABC ABC<br />
<br />
123 123<br />
def def<br />
nop nop<br />
890 890<br />
QRS QRS<br />
<br />
~-_ ~-_<br />
3 !!! /\w\R?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
)<br />
<br />
3_2 !!! /\w(?=\R)/i (6): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; f<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [5] =&gt; S<br />
)<br />
&nbsp;*/<br />
</span><span class="default">?&gt;<br />
</span>Unfortunately, I haven't got any access to a server with the latest PHP version - my local PHP is 5.3.8 and my public host's PHP is version 5.2.17.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="122413""></a>
  <div class="note">
   <strong class="user">Wirek</strong>
   <a href="#122413" class="date">20-Feb-2018 01:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A hint for those of you who are trying to fight off (or work around at least) the problem of matching a pattern correctly at the end ($) of any line in multiple lines mode (/m).<br />
<span class="default">&lt;?php <br />
</span><span class="comment">// Various OS-es have various end line (a.k.a line break) chars:<br />
// - Windows uses CR+LF (\r\n);<br />
// - Linux LF (\n);<br />
// - OSX CR (\r).<br />
// And that's why single dollar meta assertion ($) sometimes fails with multiline modifier (/m) mode - possible bug in PHP 5.3.8 or just a "feature"(?).<br />
</span><span class="default">$str</span><span class="keyword">=</span><span class="string">"ABC ABC\n\n123 123\r\ndef def\rnop nop\r\n890 890\nQRS QRS\r\r~-_ ~-_"</span><span class="keyword">;<br />
</span><span class="comment">//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; p&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; _<br />
</span><span class="default">$pat1</span><span class="keyword">=</span><span class="string">'/\w$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// This works excellent in JavaScript (Firefox 7.0.1+)<br />
</span><span class="default">$pat2</span><span class="keyword">=</span><span class="string">'/\w\r?$/mi'</span><span class="keyword">;<br />
</span><span class="default">$pat3</span><span class="keyword">=</span><span class="string">'/\w\R?$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Somehow disappointing according to php.net and pcre.org<br />
</span><span class="default">$pat4</span><span class="keyword">=</span><span class="string">'/\w\v?$/mi'</span><span class="keyword">;<br />
</span><span class="default">$pat5</span><span class="keyword">=</span><span class="string">'/(*ANYCRLF)\w$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Excellent but undocumented on php.net at the moment<br />
</span><span class="default">$n</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat1</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m1</span><span class="keyword">);<br />
</span><span class="default">$o</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat2</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m2</span><span class="keyword">);<br />
</span><span class="default">$p</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat3</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m3</span><span class="keyword">);<br />
</span><span class="default">$r</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat4</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m4</span><span class="keyword">);<br />
</span><span class="default">$s</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat5</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m5</span><span class="keyword">);<br />
echo </span><span class="default">$str</span><span class="keyword">.</span><span class="string">"\n1 !!! </span><span class="default">$pat1</span><span class="string"> (</span><span class="default">$n</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m1</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n2 !!! </span><span class="default">$pat2</span><span class="string"> (</span><span class="default">$o</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m2</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n3 !!! </span><span class="default">$pat3</span><span class="string"> (</span><span class="default">$p</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m3</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n4 !!! </span><span class="default">$pat4</span><span class="string"> (</span><span class="default">$r</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m4</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n5 !!! </span><span class="default">$pat5</span><span class="string"> (</span><span class="default">$s</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m5</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">);<br />
</span><span class="comment">// Note the difference among the three very helpful escape sequences in $pat2 (\r), $pat3 (\R), $pat4 (\v) and altered newline option in $pat5 ((*ANYCRLF)) - for some applications at least.<br />
<br />
/* The code above results in the following output:<br />
ABC ABC<br />
<br />
123 123<br />
def def<br />
nop nop<br />
890 890<br />
QRS QRS<br />
<br />
~-_ ~-_<br />
1 !!! /\w$/mi (3): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; _<br />
)<br />
<br />
2 !!! /\w\r?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
)<br />
<br />
3 !!! /\w\R?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
) <br />
<br />
4 !!! /\w\v?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
)<br />
<br />
5 !!! /(*ANYCRLF)\w$/mi (7): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; f<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [5] =&gt; S<br />
&nbsp;&nbsp;&nbsp; [6] =&gt; _<br />
)<br />
&nbsp;*/<br />
</span><span class="default">?&gt;<br />
</span>Unfortunately, I haven't got any access to a server with the latest PHP version - my local PHP is 5.3.8 and my public host's PHP is version 5.2.17.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="121639""></a>
  <div class="note">
   <strong class="user">damian dot driscoll at gmail dot com</strong>
   <a href="#121639" class="date">14-Sep-2017 10:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The PCRE_INFO_JCHANGED modifier works in version 5.6.31 but not in 5.6.16, which generates an 'unknown modifier J' warning.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="121546""></a>
  <div class="note">
   <strong class="user">arash dot dalir at gmail dot com</strong>
   <a href="#121546" class="date">22-Aug-2017 11:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
the PCRE_INFO_JCHANGED modifier is apparently not accepted as a global option (after the closing delimiter) in PHP versions &lt;= 5.4 (not checked in PHP 5.5) but allowed in PHP 5.6 (also not checked in PHP 7.X)<br />
<br />
The following pattern doesn't work in PHP 5.4, but it works in PHP 5.6:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">//test.php<br />
</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">'/(?&lt;dup_name&gt;\d{1,4})\-(?&lt;dup_name&gt;\d{1,2})/J'</span><span class="keyword">, </span><span class="string">'1234-23'</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">);<br />
<br />
</span><span class="comment">/*<br />
output in PHP 5.4:<br />
Warning: preg_match_all(): Unknown modifier 'J' in test.php on line 3<br />
NULL<br />
--------------<br />
output PHP 5.6:<br />
array(4) { <br />
&nbsp;&nbsp;&nbsp; [0]=&gt; array(1)&nbsp; { [0]=&gt; string(7) "1234-23" } <br />
&nbsp;&nbsp;&nbsp; ["dup_name"]=&gt; array(1) { [0]=&gt; string(2) "23" } <br />
&nbsp;&nbsp;&nbsp; [1]=&gt; array(1) { [0]=&gt; string(4) "1234" } <br />
&nbsp;&nbsp;&nbsp; [2]=&gt; array(1) { [0]=&gt; string(2) "23" } <br />
}<br />
*/<br />
</span><span class="default">?&gt;<br />
</span><br />
in order to resolve this issue in PHP 5.4, one can use the (?J) pattern modifier, which indicates the pattern (from that point forward) allows duplicate names for subpatterns.<br />
<br />
code which works in PHP 5.4:<br />
<span class="default">&lt;?php<br />
<br />
preg_match_all</span><span class="keyword">(</span><span class="string">'/(?J)(?&lt;dup_name&gt;\d{1,4})\-(?&lt;dup_name&gt;\d{1,2})/'</span><span class="keyword">, </span><span class="string">'1234-23'</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">);<br />
<br />
</span><span class="comment">/*<br />
output in PHP 5.4:<br />
array(4) { <br />
&nbsp;&nbsp;&nbsp; [0]=&gt; array(1) { [0]=&gt; string(7) "1234-23" } <br />
&nbsp;&nbsp;&nbsp; ["dup_name"]=&gt; array(1) { [0]=&gt; string(2) "23" } <br />
&nbsp;&nbsp;&nbsp; [1]=&gt; array(1) { [0]=&gt; string(4) "1234" } <br />
&nbsp;&nbsp;&nbsp; [2]=&gt; array(1) { [0]=&gt; string(2) "23" } <br />
}<br />
--------------<br />
output in PHP 5.6 (the same as with /J):<br />
array(4) { <br />
&nbsp;&nbsp;&nbsp; [0]=&gt; array(1)&nbsp; { [0]=&gt; string(7) "1234-23" } <br />
&nbsp;&nbsp;&nbsp; ["dup_name"]=&gt; array(1) { [0]=&gt; string(2) "23" } <br />
&nbsp;&nbsp;&nbsp; [1]=&gt; array(1) { [0]=&gt; string(4) "1234" } <br />
&nbsp;&nbsp;&nbsp; [2]=&gt; array(1) { [0]=&gt; string(2) "23" } <br />
}<br />
*/<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107498""></a>
  <div class="note">
   <strong class="user">Daniel Klein</strong>
   <a href="#107498" class="date">13-Feb-2012 11:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If the _subject_ contains utf-8 sequences the 'u' modifier should be set, otherwise a pattern such as /./ could match a utf-8 sequence as two to four individual ASCII characters. It is not a requirement, however, as you may have a need to break apart utf-8 sequences into single bytes. Most of the time, though, if you're working with utf-8 strings you should use the 'u' modifier.<br />
<br />
If the subject doesn't contain any utf-8 sequences (i.e. characters in the range 0x00-0x7F only) but the pattern does, as far as I can work out, setting the 'u' modifier would have no effect on the result.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="103348""></a>
  <div class="note">
   <strong class="user">phpman at crustynet dot org dot uk</strong>
   <a href="#103348" class="date">08-Apr-2011 08:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The description of the "u" flag is a bit misleading. It suggests that it is only required if the pattern contains UTF-8 characters, when in fact it is required if either the pattern or the subject contain UTF-8. Without it, I was having problems with preg_match_all returning invalid multibyte characters when given a UTF-8 subject string.<br />
<br />
It's fairly clear if you read the documentation for libpcre:<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; In&nbsp; order&nbsp; process&nbsp; UTF-8 strings, you must build PCRE to include UTF-8<br />
&nbsp;&nbsp; &nbsp; &nbsp; support in the code, and, in addition,&nbsp; you&nbsp; must&nbsp; call&nbsp; pcre_compile()<br />
&nbsp;&nbsp; &nbsp; &nbsp; with&nbsp; the&nbsp; PCRE_UTF8&nbsp; option&nbsp; flag,&nbsp; or the pattern must start with the<br />
&nbsp;&nbsp; &nbsp; &nbsp; sequence (*UTF8). When either of these is the case,&nbsp; both&nbsp; the&nbsp; pattern<br />
&nbsp;&nbsp; &nbsp; &nbsp; and&nbsp; any&nbsp; subject&nbsp; strings&nbsp; that&nbsp; are matched against it are treated as<br />
&nbsp;&nbsp; &nbsp; &nbsp; UTF-8 strings instead of strings of 1-byte characters.<br />
<br />
[from <a href="http://www.pcre.org/pcre.txt]" rel="nofollow" target="_blank">http://www.pcre.org/pcre.txt]</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90967""></a>
  <div class="note">
   <strong class="user">michal dot kocarek at brainbox dot cz</strong>
   <a href="#90967" class="date">18-May-2009 04:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In case you're wondering, what is the meaning of "S" modifier, this paragraph might be useful:
<br />

<br />
When "S" modifier is set, PHP calls the pcre_study() function from the PCRE API before executing the regexp. Result from the function is passed directly to pcre_exec().
<br />

<br />
For more information about pcre_study() and "Studying the pattern" check the PCRE manual on <a href="http://www.pcre.org/pcre.txt" rel="nofollow" target="_blank">http://www.pcre.org/pcre.txt</a>
<br />

<br />
PS: Note that function names "pcre_study" and "pcre_exec" used here refer to PCRE library functions written in C language and not to any PHP functions.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72997""></a>
  <div class="note">
   <strong class="user">ebarnard at marathonmultimedia dot com</strong>
   <a href="#72997" class="date">06-Feb-2007 02:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When adding comments with the /x modifier, don't use the pattern delimiter in the comments. It may not be ignored in the comments area. Example:<br />
<br />
<span class="default">&lt;?php<br />
$target </span><span class="keyword">= </span><span class="string">'some text'</span><span class="keyword">;<br />
if(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; e # Comments here<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /x'</span><span class="keyword">,</span><span class="default">$target</span><span class="keyword">)) {<br />
&nbsp;&nbsp;&nbsp; print </span><span class="string">"Target 1 hit.\n"</span><span class="keyword">;<br />
}<br />
if(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; e # /Comments here with slash<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /x'</span><span class="keyword">,</span><span class="default">$target</span><span class="keyword">)) {<br />
&nbsp;&nbsp;&nbsp; print </span><span class="string">"Target 1 hit.\n"</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
prints "Target 1 hit." but then generates a PHP warning message for the second preg_match():<br />
<br />
Warning:&nbsp; preg_match() [function.preg-match]: Unknown modifier 'C' in /ebarnard/x-modifier.php on line 11</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58409""></a>
  <div class="note">
   <strong class="user">varrah NO_GARBAGE_OR_SPAM AT mail DOT ru</strong>
   <a href="#58409" class="date">03-Nov-2005 04:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Spent a few days, trying to understand how to create a pattern for Unicode chars, using the hex codes. Finally made it, after reading several manuals, that weren't giving any practical PHP-valid examples. So here's one of them:<br />
<br />
For example we would like to search for Japanese-standard circled numbers 1-9 (Unicode codes are 0x2460-0x2468) in order to make it through the hex-codes the following call should be used:<br />
preg_match('/[\x{2460}-\x{2468}]/u', $str);<br />
<br />
Here $str is a haystack string<br />
\x{hex} - is an UTF-8 hex char-code<br />
and /u is used for identifying the class as a class of Unicode chars.<br />
<br />
Hope, it'll be useful.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="54805""></a>
  <div class="note">
   <strong class="user">hfuecks at nospam dot org</strong>
   <a href="#54805" class="date">15-Jul-2005 07:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Regarding the validity of a UTF-8 string when using the /u pattern modifier, some things to be aware of;<br />
<br />
1. If the pattern itself contains an invalid UTF-8 character, you get an error (as mentioned in the docs above - "UTF-8 validity of the pattern is checked since PHP 4.3.5"<br />
<br />
2. When the subject string contains invalid UTF-8 sequences / codepoints, it basically result in a "quiet death" for the preg_* functions, where nothing is matched but without indication that the string is invalid UTF-8<br />
<br />
3. PCRE regards five and six octet UTF-8 character sequences as valid (both in patterns and the subject string) but these are not supported in Unicode ( see section 5.9 "Character Encoding" of the "Secure Programming for Linux and Unix HOWTO" - can be found at <a href="http://www.tldp.org/ and other places " rel="nofollow" target="_blank">http://www.tldp.org/ and other places </a>)<br />
<br />
4. For an example algorithm in PHP which tests the validity of a UTF-8 string (and discards five / six octet sequences) head to: <a href="http://hsivonen.iki.fi/php-utf8/" rel="nofollow" target="_blank">http://hsivonen.iki.fi/php-utf8/</a><br />
<br />
The following script should give you an idea of what works and what doesn't;<br />
<br />
<span class="default">&lt;?php<br />
$examples </span><span class="keyword">= array(<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Valid ASCII' </span><span class="keyword">=&gt; </span><span class="string">"a"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Valid 2 Octet Sequence' </span><span class="keyword">=&gt; </span><span class="string">"\xc3\xb1"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Invalid 2 Octet Sequence' </span><span class="keyword">=&gt; </span><span class="string">"\xc3\x28"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Invalid Sequence Identifier' </span><span class="keyword">=&gt; </span><span class="string">"\xa0\xa1"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Valid 3 Octet Sequence' </span><span class="keyword">=&gt; </span><span class="string">"\xe2\x82\xa1"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Invalid 3 Octet Sequence (in 2nd Octet)' </span><span class="keyword">=&gt; </span><span class="string">"\xe2\x28\xa1"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Invalid 3 Octet Sequence (in 3rd Octet)' </span><span class="keyword">=&gt; </span><span class="string">"\xe2\x82\x28"</span><span class="keyword">,<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Valid 4 Octet Sequence' </span><span class="keyword">=&gt; </span><span class="string">"\xf0\x90\x8c\xbc"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Invalid 4 Octet Sequence (in 2nd Octet)' </span><span class="keyword">=&gt; </span><span class="string">"\xf0\x28\x8c\xbc"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Invalid 4 Octet Sequence (in 3rd Octet)' </span><span class="keyword">=&gt; </span><span class="string">"\xf0\x90\x28\xbc"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Invalid 4 Octet Sequence (in 4th Octet)' </span><span class="keyword">=&gt; </span><span class="string">"\xf0\x28\x8c\x28"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Valid 5 Octet Sequence (but not Unicode!)' </span><span class="keyword">=&gt; </span><span class="string">"\xf8\xa1\xa1\xa1\xa1"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'Valid 6 Octet Sequence (but not Unicode!)' </span><span class="keyword">=&gt; </span><span class="string">"\xfc\xa1\xa1\xa1\xa1\xa1"</span><span class="keyword">,<br />
);<br />
<br />
echo </span><span class="string">"++Invalid UTF-8 in pattern\n"</span><span class="keyword">;<br />
foreach ( </span><span class="default">$examples </span><span class="keyword">as </span><span class="default">$name </span><span class="keyword">=&gt; </span><span class="default">$str </span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"</span><span class="default">$name</span><span class="string">\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/"</span><span class="keyword">.</span><span class="default">$str</span><span class="keyword">.</span><span class="string">"/u"</span><span class="keyword">,</span><span class="string">'Testing'</span><span class="keyword">);<br />
}<br />
<br />
echo </span><span class="string">"++ preg_match() examples\n"</span><span class="keyword">;<br />
foreach ( </span><span class="default">$examples </span><span class="keyword">as </span><span class="default">$name </span><span class="keyword">=&gt; </span><span class="default">$str </span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/\xf8\xa1\xa1\xa1\xa1/u"</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$ar</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"</span><span class="default">$name</span><span class="string">: "</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; if ( </span><span class="default">count</span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">) == </span><span class="default">0 </span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"Matched nothing!\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"Matched </span><span class="keyword">{</span><span class="default">$ar</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]}</span><span class="string">\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
}<br />
<br />
echo </span><span class="string">"++ preg_match_all() examples\n"</span><span class="keyword">;<br />
foreach ( </span><span class="default">$examples </span><span class="keyword">as </span><span class="default">$name </span><span class="keyword">=&gt; </span><span class="default">$str </span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">'/./u'</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$ar</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"</span><span class="default">$name</span><span class="string">: "</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$num_utf8_chars </span><span class="keyword">= </span><span class="default">count</span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]);<br />
&nbsp;&nbsp;&nbsp; if ( </span><span class="default">$num_utf8_chars </span><span class="keyword">== </span><span class="default">0 </span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"Matched nothing!\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"Matched </span><span class="default">$num_utf8_chars</span><span class="string"> character\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
