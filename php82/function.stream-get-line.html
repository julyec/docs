<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>从资源流里读取一行直到给定的定界符</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.stream-get-filters.html">? stream_get_filters</a></li>
      <li style="float: right;"><a href="function.stream-get-meta-data.html">stream_get_meta_data ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.stream.html">Stream 函数</a></li>
    <li>从资源流里读取一行直到给定的定界符</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.stream-get-line" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">stream_get_line</h1>
  <p class="verinfo">(PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">stream_get_line</span> &mdash; <span class="dc-title">从资源流里读取一行直到给定的定界符</span></p>

 </div>
 <div class="refsect1 description" id="refsect1-function.stream-get-line-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>stream_get_line</strong></span>(<span class="methodparam"><span class="type">resource</span> <code class="parameter">$stream</code></span>, <span class="methodparam"><span class="type">int</span> <code class="parameter">$length</code></span>, <span class="methodparam"><span class="type">string</span> <code class="parameter">$ending</code><span class="initializer"> = &quot;&quot;</span></span>): <span class="type"><span class="type">string</span>|<span class="type"><span class="type false">false</span></span></span></div>

  <p class="para rdfs-comment">
      从给定的资源流里读取一行。
  </p>
  <p class="para">
   当读取到 <code class="parameter">length</code> 个字节数就结束，或者当在读取的非空字符串中发现  <code class="parameter">ending</code> （<em class="emphasis">不</em>包含到返回值里）也结束，又或者遇到了 <abbr title="End Of File">EOF</abbr> 也结束（总之以上条件中哪个先出现就以哪个为准）。
  </p>
  <p class="para">
   这个函数与 <span class="function"><a href="function.fgets.html" class="function">fgets()</a></span> 几乎是相同的，唯一的区别是在这个函数里面允许指定行尾的定界符，而不是使用标准的 \n， \r 还有 \r\n ，并且返回值中<em class="emphasis">不</em>包含定界符。（翻译注：也可以把 \n 等作为定界符传入 <code class="parameter">ending</code> ）
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.stream-get-line-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>
    
     <dt>
<code class="parameter">stream</code></dt>

     <dd>

      <p class="para">
       一个有效的文件句柄。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">length</code></dt>

     <dd>

      <p class="para">
       需要从句柄中读取的最大字节数。不支持负值。
       <code class="literal">0</code> 表示默认的套接字块大小（socket chunk size），即
       <code class="literal">8192</code> 字节。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">ending</code></dt>

     <dd>

      <p class="para">
       可选参数，字符串定界符。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.stream-get-line-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   返回一个字符串，该字符串的内容根据 <code class="parameter">length</code>
   字节数从 <code class="parameter">stream</code> 里读取， 或者在失败时返回 <strong><code>false</code></strong>。
  </p>
 </div>

  
 <div class="refsect1 seealso" id="refsect1-function.stream-get-line-seealso">
  <h3 class="title">参见</h3>
  <ul class="simplelist">
   <li class="member"><span class="function"><a href="function.fread.html" class="function" rel="rdfs-seeAlso">fread()</a> - 读取文件（可安全用于二进制文件）</span></li>
   <li class="member"><span class="function"><a href="function.fgets.html" class="function" rel="rdfs-seeAlso">fgets()</a> - 从文件指针中读取一行</span></li>
   <li class="member"><span class="function"><a href="function.fgetc.html" class="function" rel="rdfs-seeAlso">fgetc()</a> - 从文件指针中读取字符</span></li>
  </ul>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="128600""></a>
  <div class="note">
   <strong class="user">codertookode at xport dot top</strong>
   <a href="#128600" class="date">10-Jun-2023 10:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Simple example I've used with websocket and found it faster than feof<br />
<br />
while(($line = stream_get_line($sock, 0, "\r\n"))&nbsp; !==&nbsp; false){<br />
&nbsp;&nbsp;&nbsp; echo $line;<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111731""></a>
  <div class="note">
   <strong class="user">kjeld at mail4us dot dk</strong>
   <a href="#111731" class="date">21-Mar-2013 10:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have been struggling with the problem that stream_get_line() sometimes reads too much when the 3rd parameter is used (and the 3rd parameter has a length greater than 1), so $ending is actually contained in the data returned (https://bugs.php.net/bug.php?id=63240).<br />
<br />
I don't have the option of upgrading my PHP version but it seems that a workaround can be to insert:<br />
<br />
&nbsp;&nbsp;&nbsp; fseek($fp, ftell($fp));<br />
<br />
just before calling stream_get_line().</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111034""></a>
  <div class="note">
   <strong class="user">carltondickson</strong>
   <a href="#111034" class="date">08-Jan-2013 04:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are specifying the 3rd optional "ending" parameter as a string which is more than one character and actually find that the line returned by the function sometimes contains this "ending" value it may be related to the following bug, https://bugs.php.net/bug.php?id=63240<br />
<br />
Our server was running 5.3.18 and when we upgraded to 5.3.20 it worked fine, I believe this was fixed in 5.3.19 though.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="109339""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#109339" class="date">08-Jul-2012 03:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
WARNING:<br />
Specifying a length of 0 does NOT give you an infinite length, contrary to what the documentation might suggest. Instead, setting a length of 0 just makes the function default to a length of 8192. To be precise, it gets the value PHP_SOCK_CHUNK_SIZE (8192) in ext/standard/streamsfuncs.c.<br />
<br />
So, let's say you're trying to read ALL data until you reach a "\x03" (decimal 3) byte. How do you GUARANTEE that this is the case? Well, there's no way! The only thing you can do stream_get_lin() into a "master" string, then fseek() backwards by 1 character, then fgetc() and verify that it's "\x03". If you don't see a "\x03", it means that stream_get_line() has aborted after 8192 bytes and before hitting "\x03", and you'll have to call it again. Keep appending the return values to a "master" string until you hit a "\x03" or EOF... That's the ONLY way to properly build a string that contains EVERYTHING until the character you're looking for.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94879""></a>
  <div class="note">
   <strong class="user">pk at ritm dot ru</strong>
   <a href="#94879" class="date">30-Nov-2009 09:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
fgets is faster but stream_get_line is more useful in a tcp server scripts.<br />
<br />
when fgets reads some bytes from socket, where EOF is reached, it returns bool(false) same as stream_get_line<br />
<br />
BUT if remote client drops connection, and server script will try to read some data with function fgets, function will return bool(false), and stream_get_line will return string(0) ""<br />
<br />
so you can detect remote client disconnection with stream_get_line, and cannot with fgets</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="85193""></a>
  <div class="note">
   <strong class="user">amoo_miki at yahoo dot com</strong>
   <a href="#85193" class="date">19-Aug-2008 10:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If the "ending" is a string, there are cases where the function doesn't return the correct value for the first time it is called. Don't be shocked if you find it returning a string value of upto "length" that includes the "ending". (See bug #44607)
<br />

<br />
If the "ending" is just a single character, the function would always work correctly. ("\n" is a single character)
<br />

<br />
Temporarily, until this is fixed, the below function can be used:
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">istream_get_line</span><span class="keyword">(&amp;</span><span class="default">$fp</span><span class="keyword">, </span><span class="default">$length</span><span class="keyword">, </span><span class="default">$end</span><span class="keyword">) {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$current </span><span class="keyword">= </span><span class="default">ftell</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">, </span><span class="default">$length</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">strpos</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$end</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$i </span><span class="keyword">=== </span><span class="default">FALSE</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$str</span><span class="keyword">;&nbsp; &nbsp; 
<br />
&nbsp;&nbsp;&nbsp; } else {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fseek</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">, </span><span class="default">$current </span><span class="keyword">+ </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$end</span><span class="keyword">));
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; }
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79944""></a>
  <div class="note">
   <strong class="user">Mat Jaggard  at  Tickets dot com</strong>
   <a href="#79944" class="date">20-Dec-2007 08:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've spent quite a while trying to get stream_get_line to get a chunk encoded html file and to finish correctly at the end so that I can pipeline requests.<br />
<br />
This is the function I have come up with.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">getURLContents</span><span class="keyword">(</span><span class="default">$url</span><span class="keyword">, </span><span class="default">$ip</span><span class="keyword">, </span><span class="default">$port</span><span class="keyword">, </span><span class="default">$ssl </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">, </span><span class="default">$closeConnection </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$ssl</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ssl </span><span class="keyword">= </span><span class="string">'ssl://'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ssl </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$fp </span><span class="keyword">= </span><span class="default">pfsockopen</span><span class="keyword">(</span><span class="default">$ssl</span><span class="keyword">.</span><span class="default">$ip</span><span class="keyword">, </span><span class="default">$port</span><span class="keyword">, </span><span class="default">$errno</span><span class="keyword">, </span><span class="default">$errstr</span><span class="keyword">, </span><span class="default">MAX_TIME_TO_START_CONNECTION</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$fp</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">=&nbsp; </span><span class="string">'GET '</span><span class="keyword">.</span><span class="default">$url</span><span class="keyword">.</span><span class="string">" HTTP/1.1\r\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="string">'Host: '</span><span class="keyword">.</span><span class="default">$ip</span><span class="keyword">.</span><span class="string">':'</span><span class="keyword">.</span><span class="default">$port</span><span class="keyword">.</span><span class="string">"\r\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$closeConnection</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="string">"Connection: close\r\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="string">"Connection: keep-alive\r\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="string">"\r\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (!</span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">, </span><span class="default">$out</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">'Problem writing to socket, opening a new connection.'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$fp </span><span class="keyword">= </span><span class="default">pfsockopen</span><span class="keyword">(</span><span class="default">$ssl</span><span class="keyword">.</span><span class="default">$ip</span><span class="keyword">, </span><span class="default">$port</span><span class="keyword">, </span><span class="default">$errno</span><span class="keyword">, </span><span class="default">$errstr</span><span class="keyword">, </span><span class="default">MAX_TIME_TO_START_CONNECTION</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">, </span><span class="default">$out</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$theData </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$notDone </span><span class="keyword">= </span><span class="default">true</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">stream_set_blocking</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$startTime </span><span class="keyword">= </span><span class="default">time</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$lastTime </span><span class="keyword">= </span><span class="default">$startTime</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; while (!</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">) &amp;&amp; !</span><span class="default">$done </span><span class="keyword">&amp;&amp; ((</span><span class="default">$startTime </span><span class="keyword">+ </span><span class="default">MAX_TIME_FOR_THE_RESPONSE</span><span class="keyword">) &gt; </span><span class="default">time</span><span class="keyword">()))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">usleep</span><span class="keyword">(</span><span class="default">100</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$theNewData </span><span class="keyword">= </span><span class="default">stream_get_line</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">, </span><span class="default">1024</span><span class="keyword">, </span><span class="string">"\n"</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$theData </span><span class="keyword">.= </span><span class="default">$theNewData</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$done </span><span class="keyword">= (</span><span class="default">trim</span><span class="keyword">(</span><span class="default">$theNewData</span><span class="keyword">) === </span><span class="string">'0'</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">'ERROR CONNECTING TO '</span><span class="keyword">.</span><span class="default">$ip</span><span class="keyword">.</span><span class="string">':'</span><span class="keyword">.</span><span class="default">$port</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$closeConnection</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$theData</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="67555""></a>
  <div class="note">
   <strong class="user">dante at lorenso dot com</strong>
   <a href="#67555" class="date">08-Jun-2006 12:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
My testing has found this function to be dramatically faster than fgets on PHP 5.1.14.&nbsp; The difference is probably due to how buffering is used internally.&nbsp; Compare the following:
<br />
<span class="default">&lt;?php
<br />
</span><span class="comment">// reads 10,000 lines in 27 seconds
<br />
</span><span class="keyword">while (!</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$handle</span><span class="keyword">)) {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$line </span><span class="keyword">= </span><span class="default">fgets</span><span class="keyword">(</span><span class="default">$handle</span><span class="keyword">, </span><span class="default">1000000</span><span class="keyword">); 
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>vs.
<br />
<span class="default">&lt;?php
<br />
</span><span class="comment">// reads 10,000 lines in 0.5 seconds
<br />
</span><span class="keyword">while (!</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$handle</span><span class="keyword">)) {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$line </span><span class="keyword">= </span><span class="default">stream_get_line</span><span class="keyword">(</span><span class="default">$handle</span><span class="keyword">, </span><span class="default">1000000</span><span class="keyword">, </span><span class="string">"\n"</span><span class="keyword">);
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="64568""></a>
  <div class="note">
   
   <a href="#64568" class="date">18-Apr-2006 02:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In version 5.0.4 using this funtion and then calling ftell($stream) would give you the position up to but not including the "ending" string. <br />
<br />
When I rev'd to PHP version 5.1.2, calling this function then using ftell($stream) would give the position up to AND including the "ending" string<br />
<br />
for example, parsing HTTP responses.<br />
<br />
The response from apache using curl....<br />
------------------------------------------------------------<br />
HTTP/1.1 200 OK<br />
Date: Tue, 18 Apr 2006 20:54:59 GMT<br />
Server: Apache/1.3.33 (Unix) PHP/5.0.4 mod_ssl/2.8.22 OpenSSL/0.9.7e<br />
X-Powered-By: PHP/5.0.4<br />
Transfer-Encoding: chunked<br />
Content-Type: text/html<br />
<br />
&lt;html&gt;&lt;body&gt;test&lt;/body&gt;&lt;/html&gt;<br />
-------------------------------------------------------------<br />
<br />
The code:<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp; $headers </span><span class="keyword">= </span><span class="default">stream_get_line</span><span class="keyword">(</span><span class="default">$in</span><span class="keyword">,</span><span class="default">4096</span><span class="keyword">,</span><span class="string">"\r\n\r\n"</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; </span><span class="default">fseek </span><span class="keyword">(</span><span class="default">$in</span><span class="keyword">,</span><span class="default">ftell</span><span class="keyword">(</span><span class="default">$in</span><span class="keyword">)+</span><span class="default">4</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; while (!</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$in</span><span class="keyword">)){<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">fputs </span><span class="keyword">(</span><span class="default">$out</span><span class="keyword">,</span><span class="default">stream_get_line</span><span class="keyword">(</span><span class="default">$in</span><span class="keyword">,</span><span class="default">4096</span><span class="keyword">,</span><span class="string">''</span><span class="keyword">));<br />
&nbsp;&nbsp; }<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
prior to my 5.0.4 this worked perfectly, trimming the \r\n\r\n section of the HTTP response and seperating the top into the $headers string, and the rest was placed into the file handle $out.<br />
<br />
using php 5.1.2, the above code chopps off the first 4 bytes of the HTTP response and puts <br />
<br />
l&gt;&lt;body&gt;test&lt;/body&gt;&lt;/html&gt; <br />
<br />
into $out.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
