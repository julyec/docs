<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>从套接字中读取最大长度的数据</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.socket-listen.html">? socket_listen</a></li>
      <li style="float: right;"><a href="function.socket-recv.html">socket_recv ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.sockets.html">Socket 函数</a></li>
    <li>从套接字中读取最大长度的数据</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.socket-read" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">socket_read</h1>
  <p class="verinfo">(PHP 4 &gt;= 4.1.0, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">socket_read</span> &mdash; <span class="dc-title">从套接字中读取最大长度的数据</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.socket-read-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>socket_read</strong></span>(<span class="methodparam"><span class="type"><a href="class.socket.html" class="type Socket">Socket</a></span> <code class="parameter">$socket</code></span>, <span class="methodparam"><span class="type">int</span> <code class="parameter">$length</code></span>, <span class="methodparam"><span class="type">int</span> <code class="parameter">$mode</code><span class="initializer"> = <strong><code>PHP_BINARY_READ</code></strong></span></span>): <span class="type"><span class="type">string</span>|<span class="type"><span class="type false">false</span></span></span></div>

  <p class="para rdfs-comment">
   <span class="function"><strong>socket_read()</strong></span> 函数是从 <span class="function"><a href="function.socket-create.html" class="function">socket_create()</a></span>
   或 <span class="function"><a href="function.socket-accept.html" class="function">socket_accept()</a></span> 函数所创建的 <span class="classname"><a href="class.socket.html" class="classname">Socket</a></span>
   实例 <code class="parameter">socket</code> 中读取数据。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.socket-read-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>
    
     <dt>
<code class="parameter">socket</code></dt>

     <dd>

      <p class="para">
       使用 <span class="function"><a href="function.socket-create.html" class="function">socket_create()</a></span>
       或 <span class="function"><a href="function.socket-accept.html" class="function">socket_accept()</a></span>
       函数创建的 <span class="classname"><a href="class.socket.html" class="classname">Socket</a></span> 实例。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">length</code></dt>

     <dd>

      <p class="para">
       <code class="parameter">length</code> 参数指定了最大能够读取的字节数。否则您可以使用
       <strong><code>\r</code></strong>、<strong><code>\n</code></strong>、<strong><code>\0</code></strong>
       结束读取（根据 <code class="parameter">mode</code> 参数设置，请参见下文）。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">mode</code></dt>

     <dd>

      <p class="para">
       可选参数 <code class="parameter">mode</code> 是一个命名常量：
       <ul class="itemizedlist">
        <li class="listitem">
         <span class="simpara">
          <strong><code>PHP_BINARY_READ</code></strong> （默认）- 使用系统的
          <code class="literal">recv()</code> 函数。二进制安全地读取数据。
         </span>
        </li>
        <li class="listitem">
         <span class="simpara">
          <strong><code>PHP_NORMAL_READ</code></strong> - 读取到
          <code class="literal">\n</code>、<code class="literal">\r</code> 时停止。
         </span>
        </li>
       </ul>
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.socket-read-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   <span class="function"><strong>socket_read()</strong></span> 返回一个字符串，表示接收到的数据。如果发生了错误（包括远程主机关闭了连接），则返回 <strong><code>false</code></strong>。错误码可使用
   <span class="function"><a href="function.socket-last-error.html" class="function">socket_last_error()</a></span> 获取。也可使用 <span class="function"><a href="function.socket-strerror.html" class="function">socket_strerror()</a></span>
   来获取错误码的文字描述。
  </p>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
    当套接字中没有更多数据可读取时，<span class="function"><strong>socket_read()</strong></span>
    返回一个长度为 0 的空字符串（&quot;&quot;）。
   </p>
  </p></blockquote>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.socket-read-changelog">
  <h3 class="title">更新日志</h3>
  <table class="doctable informaltable">
   
    <thead>
     <tr>
      <th>版本</th>
      <th>说明</th>
     </tr>

    </thead>

    <tbody class="tbody">
     <tr>
  <td>8.0.0</td>
  <td>
   现在 <code class="parameter">socket</code> 是 <span class="classname"><a href="class.socket.html" class="classname">Socket</a></span> 实例，
   之前是 <span class="type">resource</span>。
  </td>
 </tr>

    </tbody>
   
  </table>

 </div>


 <div class="refsect1 seealso" id="refsect1-function.socket-read-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.socket-accept.html" class="function" rel="rdfs-seeAlso">socket_accept()</a> - 接受套接字上的连接</span></li>
    <li class="member"><span class="function"><a href="function.socket-bind.html" class="function" rel="rdfs-seeAlso">socket_bind()</a> - 给套接字绑定名字</span></li>
    <li class="member"><span class="function"><a href="function.socket-connect.html" class="function" rel="rdfs-seeAlso">socket_connect()</a> - 开启一个套接字连接</span></li>
    <li class="member"><span class="function"><a href="function.socket-listen.html" class="function" rel="rdfs-seeAlso">socket_listen()</a> - 监听套接字的连接</span></li>
    <li class="member"><span class="function"><a href="function.socket-last-error.html" class="function" rel="rdfs-seeAlso">socket_last_error()</a> - 返回套接字上的最后一个错误</span></li>
    <li class="member"><span class="function"><a href="function.socket-strerror.html" class="function" rel="rdfs-seeAlso">socket_strerror()</a> - 返回描述套接字错误的字符串</span></li>
    <li class="member"><span class="function"><a href="function.socket-write.html" class="function" rel="rdfs-seeAlso">socket_write()</a> - 向套接字写数据</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="124492""></a>
  <div class="note">
   <strong class="user">d dot bergloev at gmail dot com</strong>
   <a href="#124492" class="date">07-Dec-2019 10:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Binary read is the correct way to read data in most cases, whereas "normal read", is a strange and lazy PHP built mode, that works mostly with terminal data. <br />
<br />
If you want to keep track of closed connections with binary read, the correct way is NOT to switch from binary to "normal", like some suggests. The correct way is to create some test scenarios and see how PHP deals with specific circumstances. <br />
<br />
Here is what a quick test shows, when working with non-blocking sockets. <br />
<br />
<span class="default">&lt;?php<br />
$input </span><span class="keyword">= </span><span class="default">socket_read</span><span class="keyword">(</span><span class="default">$socket</span><span class="keyword">, </span><span class="default">1024</span><span class="keyword">);<br />
<br />
</span><span class="comment">// In most cases, error produces an empty string and not FALSE<br />
</span><span class="keyword">if (</span><span class="default">$input </span><span class="keyword">=== </span><span class="default">FALSE </span><span class="keyword">|| </span><span class="default">strcmp</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">, </span><span class="string">''</span><span class="keyword">) == </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$code </span><span class="keyword">= </span><span class="default">socket_last_error</span><span class="keyword">(</span><span class="default">$socket</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// You MUST clear the error, or it will not change on next read<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">socket_clear_error</span><span class="keyword">(</span><span class="default">$socket</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$code </span><span class="keyword">== </span><span class="default">SOCKET_EAGAIN</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Nothing to read from non-blocking socket, try again later...<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">} else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Connection most likely closed, especially if $code is '0'<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">}<br />
<br />
} else {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Deal with the data<br />
</span><span class="keyword">}<br />
</span><span class="default">?&gt;<br />
</span><br />
There are more errors to consider, but this will get you started.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="122941""></a>
  <div class="note">
   <strong class="user">Arvy</strong>
   <a href="#122941" class="date">13-Jul-2018 03:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
On non-blocking sockets, the function will return "" if no data is received, and even if the client disconnects.<br />
<br />
If you want to check if the client disconnected, use ===.<br />
<br />
$ret=socket_read($socket);<br />
<br />
$ret=="" : connected but no data received or client disconnected<br />
$ret==="" : client disconnected for sure</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="121426""></a>
  <div class="note">
   <strong class="user">sahel dot nuri at outlook dot com</strong>
   <a href="#121426" class="date">24-Jul-2017 03:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This little, important fact would save your time.<br />
If you want to recognize that your client is disconnected without any message, you have to select the right flag.<br />
Because, if you use the flag PHP_BINARY_READ:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">read</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; while(</span><span class="default">$buf </span><span class="keyword">= @</span><span class="default">socket_read</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">, </span><span class="default">1024 </span><span class="keyword">[, </span><span class="default">PHP_BINARY_READ </span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$buf </span><span class="keyword">= </span><span class="default">trim</span><span class="keyword">(</span><span class="default">$buf</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$buf</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span>and the users disconnects, the function will returns an empty string.<br />
But if you use the flag PHP_NORMAL_READ:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">read</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; while(</span><span class="default">$buf </span><span class="keyword">= @</span><span class="default">socket_read</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">, </span><span class="default">1024</span><span class="keyword">, </span><span class="default">PHP_NORMAL_READ</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$buf </span><span class="keyword">= </span><span class="default">trim</span><span class="keyword">(</span><span class="default">$buf</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$buf</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span>the function will returns a false.<br />
<br />
I hope this will help you. I wasted one hour of my time to solve this problem.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="120447""></a>
  <div class="note">
   <strong class="user">berniev</strong>
   <a href="#120447" class="date">11-Jan-2017 03:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is not obvious from the docs or notes...<br />
PHP_NORMAL_MODE is different to PHP_BINARY in that the former blocks regardless of socket_set_nonblock, the latter respects block and nonblock.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="117902""></a>
  <div class="note">
   <strong class="user">dhaubert dot ti at gmail dot com</strong>
   <a href="#117902" class="date">28-Aug-2015 03:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A way to wait for a message response by the socket or take the first message incoming.<br />
<br />
Note that if the server turn offline, you have a socket resource, but while trying socket_read(), it gives you a warning message that will fill your hard drive kickly due to logging.<br />
<br />
The example above try read the message at best 3 times, 3 seconds sleeping for another reading. <br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">waitResponse</span><span class="keyword">(</span><span class="default">$response </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">) {<br />
&nbsp;&nbsp; </span><span class="default">$status </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">$tries </span><span class="keyword">= </span><span class="default">3</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">$counter </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; while (</span><span class="default">$status </span><span class="keyword">== </span><span class="default">$response</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$status </span><span class="keyword">= </span><span class="default">socket_read</span><span class="keyword">(</span><span class="default">$socket</span><span class="keyword">, </span><span class="default">1024</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(!</span><span class="default">$status</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(</span><span class="default">$counter </span><span class="keyword">&gt;= </span><span class="default">$tries</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$counter</span><span class="keyword">++;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">3</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; }<br />
return </span><span class="default">$response</span><span class="keyword">;<br />
}</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115903""></a>
  <div class="note">
   <strong class="user">cottton at i-stats dot net</strong>
   <a href="#115903" class="date">12-Oct-2014 09:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
quote:<br />
"Note:<br />
socket_read() returns a zero length string ("") when there is no more data to read."<br />
<br />
This is not true!<br />
<br />
In a while loop&nbsp; <br />
(example case few bytes to receive - just enough for 1 call, but you use a loop to be sure you received all data)<br />
if you use <br />
&lt;? socket_set_block($socket); ?&gt;<br />
you will get:<br />
1st call in loop: data<br />
2nd call in loop: a block forever, if there isnt data anymore or w/e happen to the "other side"<br />
<br />
So ofc you want to use <br />
&lt;? socket_set_nonblock($socket); ?&gt;<br />
and you will get:<br />
1st call in loop: data<br />
2nd call in loop: socket_read() returns FALSE (bool) and socket_last_error() gives you a SOCKET_EWOULDBLOCK (<a href="http://de1.php.net/manual/de/sockets.constants.php" rel="nofollow" target="_blank">http://de1.php.net/manual/de/sockets.constants.php</a>)<br />
<br />
There is not a single time i got a empty string back from socket_read.<br />
And im "working" on this problem(bug?) since a week or so.<br />
<br />
You better use socket_recv() instead.<br />
(good luck)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="103154""></a>
  <div class="note">
   <strong class="user">eng.mrkto.com</strong>
   <a href="#103154" class="date">29-Mar-2011 04:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems like in socket_* functions in BLOCKING mode where is no way to check if more than $length bytes are still available in socket (like stream_get_meta_data()['unread_bytes']).<br />
So you need to choose your prefered maximum $length (like 133693415:) or use non-blocking mode (for realy big data reciving).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="89133""></a>
  <div class="note">
   <strong class="user">t33th4n at gmail dot com</strong>
   <a href="#89133" class="date">23-Feb-2009 12:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I don't know if is it stated anywhere with this clearance, but here is the source code for detecting the connection abort/closure for sockets testing with socket_read function:
<br />

<br />
<span class="default">&lt;?php
<br />
$buf </span><span class="keyword">= @</span><span class="default">socket_read</span><span class="keyword">(</span><span class="default">$routes</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">][</span><span class="default">$connectionid</span><span class="keyword">][</span><span class="string">'tunnelsrc'</span><span class="keyword">], </span><span class="default">$buffer_size</span><span class="keyword">);
<br />
if (</span><span class="default">$buf </span><span class="keyword">=== </span><span class="string">''</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$routes</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">][</span><span class="default">$connectionid</span><span class="keyword">][</span><span class="string">'disconnected'</span><span class="keyword">]=</span><span class="string">'Conenction abort at source side'</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
($buf === '') is the key :)
<br />

<br />
I was making an ecrypted tunnel script with mcrypt and was annoying that i could not detect the connection abort from any side.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84169""></a>
  <div class="note">
   <strong class="user">tech [{at}] swatcash [{dot}] com</strong>
   <a href="#84169" class="date">01-Jul-2008 04:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Messed up the end of my previous one. Corrected version here: <br />
<br />
a simple work around to non-blocking working with normal read is like so:<br />
<br />
$read = array($socket);<br />
$write&nbsp; = NULL;<br />
$except = NULL;<br />
while(1) {<br />
&nbsp;&nbsp;&nbsp; $num_changed_sockets = socket_select($read, $write, $except, 0, 1);<br />
&nbsp;&nbsp;&nbsp; if ( $num_changed_sockets &gt; '0' ) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; socket_read($socket,10000,PHP_NORMAL_READ);<br />
&nbsp;&nbsp;&nbsp; } <br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79853""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#79853" class="date">15-Dec-2007 11:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
On non-blocking connections it may not return full length requested.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79314""></a>
  <div class="note">
   <strong class="user">nad0r1 at hush dot ai</strong>
   <a href="#79314" class="date">20-Nov-2007 07:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another way to bypass the annoying thing with telnet, that send each character as a string ,is to check if the response is "\r\n", that is the string that telnet sends when the user presses enter.<br />
<br />
Here is an example:<br />
<span class="default">&lt;?php<br />
error_reporting</span><span class="keyword">(</span><span class="default">E_ALL</span><span class="keyword">);<br />
<br />
</span><span class="comment">/* Allow the script to hang around waiting for connections. */<br />
</span><span class="default">set_time_limit</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">);<br />
<br />
</span><span class="comment">/* Turn on implicit output flushing so we see what we're getting<br />
&nbsp;* as it comes in. */<br />
</span><span class="default">ob_implicit_flush</span><span class="keyword">();<br />
<br />
</span><span class="default">$address </span><span class="keyword">= </span><span class="string">'127.0.0.1'</span><span class="keyword">;<br />
</span><span class="default">$port </span><span class="keyword">= </span><span class="default">100</span><span class="keyword">;<br />
<br />
if ((</span><span class="default">$sock </span><span class="keyword">= </span><span class="default">socket_create</span><span class="keyword">(</span><span class="default">AF_INET</span><span class="keyword">, </span><span class="default">SOCK_STREAM</span><span class="keyword">, </span><span class="default">SOL_TCP</span><span class="keyword">)) === </span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"socket_create() failed: reason: " </span><span class="keyword">. </span><span class="default">socket_strerror</span><span class="keyword">(</span><span class="default">socket_last_error</span><span class="keyword">()) . </span><span class="string">"\n"</span><span class="keyword">;<br />
}<br />
<br />
if (</span><span class="default">socket_bind</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">, </span><span class="default">$address</span><span class="keyword">, </span><span class="default">$port</span><span class="keyword">) === </span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"socket_bind() failed: reason: " </span><span class="keyword">. </span><span class="default">socket_strerror</span><span class="keyword">(</span><span class="default">socket_last_error</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">)) . </span><span class="string">"\n"</span><span class="keyword">;<br />
}<br />
else <br />
&nbsp; echo </span><span class="string">'Socket ' </span><span class="keyword">. </span><span class="default">$address </span><span class="keyword">. </span><span class="string">':' </span><span class="keyword">. </span><span class="default">$port </span><span class="keyword">. </span><span class="string">" has been opened\n"</span><span class="keyword">;<br />
<br />
if (</span><span class="default">socket_listen</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">, </span><span class="default">5</span><span class="keyword">) === </span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"socket_listen() failed: reason: " </span><span class="keyword">. </span><span class="default">socket_strerror</span><span class="keyword">(</span><span class="default">socket_last_error</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">)) . </span><span class="string">"\n"</span><span class="keyword">;<br />
}<br />
else <br />
&nbsp;&nbsp; echo </span><span class="string">"Listening for new clients..\n"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; </span><span class="default">$client_id </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
do {<br />
&nbsp;&nbsp;&nbsp; if ((</span><span class="default">$msgsock </span><span class="keyword">= </span><span class="default">socket_accept</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">)) === </span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"socket_accept() failed: reason: " </span><span class="keyword">. </span><span class="default">socket_strerror</span><span class="keyword">(</span><span class="default">socket_last_error</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">)) . </span><span class="string">"\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$client_id </span><span class="keyword">+= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; echo </span><span class="string">"Client #" </span><span class="keyword">.</span><span class="default">$client_id </span><span class="keyword">.</span><span class="string">": Connect\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/* Send instructions. */<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$msg </span><span class="keyword">= </span><span class="string">"\nWelcome to the PHP Test Server. \n" </span><span class="keyword">.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">"To quit, type 'quit'. To shut down the server type 'shutdown'.\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">socket_write</span><span class="keyword">(</span><span class="default">$msgsock</span><span class="keyword">, </span><span class="default">$msg</span><span class="keyword">, </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$msg</span><span class="keyword">));<br />
</span><span class="default">$cur_buf </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; do {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">false </span><span class="keyword">=== (</span><span class="default">$buf </span><span class="keyword">= </span><span class="default">socket_read</span><span class="keyword">(</span><span class="default">$msgsock</span><span class="keyword">, </span><span class="default">2048</span><span class="keyword">))) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"socket_read() failed: reason: " </span><span class="keyword">. </span><span class="default">socket_strerror</span><span class="keyword">(</span><span class="default">socket_last_error</span><span class="keyword">(</span><span class="default">$msgsock</span><span class="keyword">)) . </span><span class="string">"\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break </span><span class="default">2</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$buf </span><span class="keyword">== </span><span class="string">"\r\n"</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$cur_buf </span><span class="keyword">== </span><span class="string">'quit'</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">'Client #' </span><span class="keyword">.</span><span class="default">$client_id </span><span class="keyword">.</span><span class="string">': Disconnect' </span><span class="keyword">. </span><span class="string">"\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$cur_buf </span><span class="keyword">== </span><span class="string">'shutdown'</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">socket_close</span><span class="keyword">(</span><span class="default">$msgsock</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break </span><span class="default">2</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="default">$talkback </span><span class="keyword">= </span><span class="string">"Unknown command: " </span><span class="keyword">. </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">"\r\n"</span><span class="keyword">, </span><span class="string">'\r\n'</span><span class="keyword">, </span><span class="default">$cur_buf</span><span class="keyword">) .</span><span class="string">"\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="default">socket_write</span><span class="keyword">(</span><span class="default">$msgsock</span><span class="keyword">, </span><span class="default">$talkback</span><span class="keyword">, </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$talkback</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="comment">// }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">echo </span><span class="string">'Client #' </span><span class="keyword">.</span><span class="default">$client_id </span><span class="keyword">.</span><span class="string">': ' </span><span class="keyword">. </span><span class="default">$cur_buf </span><span class="keyword">. </span><span class="string">"\n"</span><span class="keyword">; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$cur_buf </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else </span><span class="default">$cur_buf </span><span class="keyword">.= </span><span class="default">$buf</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; } while (</span><span class="default">true</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">socket_close</span><span class="keyword">(</span><span class="default">$msgsock</span><span class="keyword">);<br />
} while (</span><span class="default">true</span><span class="keyword">);<br />
<br />
</span><span class="default">socket_close</span><span class="keyword">(</span><span class="default">$sock</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="76470""></a>
  <div class="note">
   <strong class="user">jgbustos at gmail dot com</strong>
   <a href="#76470" class="date">17-Jul-2007 05:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PHP on win32 developers, please look at this bug report before using the PHP_NORMAL_READ option:<br />
<br />
<a href="http://bugs.php.net/bug.php?id=21197" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=21197</a><br />
<br />
In a nutshell, using PHP_NORMAL_READ will make your calls to socket_read() return an empty buffer every time.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="76069""></a>
  <div class="note">
   <strong class="user">ein at anti-logic dot com</strong>
   <a href="#76069" class="date">28-Jun-2007 11:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
the proper way to detect a closed connection is to check socket_last_error.<br />
<br />
Connection reset by peer is 104 (either use socket_strerror or don't suppress errors for the time being to find these out), sooo.<br />
<br />
while($buffer=@socket_read($sock,512,PHP_NORMAL_READ)){<br />
&nbsp;&nbsp;&nbsp; echo $buffer;<br />
}<br />
if(socket_last_error($sock) == 104) {<br />
&nbsp;&nbsp;&nbsp; echo "Connection closed";<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75747""></a>
  <div class="note">
   <strong class="user">nuitari-php at nuitari dot net</strong>
   <a href="#75747" class="date">13-Jun-2007 11:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PHP_NORMAL_READ - reading stops at \n or \r.<br />
<br />
This seems to be meant literally.<br />
If there is a \r, then it will stop reading, even if there is a \n right after it. You have to call the read again just to get rid of the \n.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72922""></a>
  <div class="note">
   <strong class="user">dotpointer</strong>
   <a href="#72922" class="date">04-Feb-2007 03:27</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PHP 5.2.0 / Win32 / Apache 1.3 - It seems like...<br />
<br />
PHP_BINARY_READ - works, but returns '', not FALSE...<br />
- is blocking, until data received or connection closed<br />
- does pass-through \r\n etc.<br />
- returns data on data, '' on connection closed<br />
- you can detect closed connection by checking for '' (not FALSE as stated i manual)<br />
<br />
PHP_NORMAL_READ - not working so good...<br />
- is non-blocking<br />
- does not pass-through \r\n etc.<br />
- returns false on no-data, false on connection closed :(<br />
- (no way here to detect a closed connection...?)<br />
- (is this a bug? <a href="http://bugs.php.net/bug.php?id=21880 " rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=21880 </a>)<br />
- (is this a bug? <a href="http://bugs.php.net/bug.php?id=21197 " rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=21197 </a>)<br />
- (could not get data from this option at all in fact...)<br />
<br />
PHP_BINARY_READ seems to be the "right way to go" <br />
for now. Both checking for '' and false to detect closed <br />
connection is probably smart, as this "bug"(?) may <br />
be fixed...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69039""></a>
  <div class="note">
   <strong class="user">Niels laukens</strong>
   <a href="#69039" class="date">21-Aug-2006 12:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This paragraph is confusing:<br />
<br />
socket_read() returns the data as a string on success, or FALSE on error (including if the remote host has closed the connection). The error code can be retrieved with socket_last_error(). This code may be passed to socket_strerror() to get a textual representation of the error.<br />
Note: socket_read() returns a zero length string ("") when there is no more data to read.<br />
<br />
My tests (on PHP 5.1.4) show that when you socket_read() on a shutdown-socket, it returns FALSE when using PHP_NORMAL_READ, but returns "" when reading in PHP_BINARY_READ.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="51063""></a>
  <div class="note">
   <strong class="user">Bill Kuker</strong>
   <a href="#51063" class="date">18-Mar-2005 07:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Just a note that on my system the length seems to have an undocumented upper bound of 65536. I was being lazy and not read()ing in a while loop until I pointed it at real data ;)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42700""></a>
  <div class="note">
   <strong class="user">michi at tr51 dot org</strong>
   <a href="#42700" class="date">26-May-2004 12:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
if you'd like to make a "socket_read" on a linux-system connected with a flash-client (v. 6.0 r81) you have to send a string to the connected port:<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp; </span><span class="keyword">...&nbsp; </span><span class="comment">//initialising communication<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$string </span><span class="keyword">= </span><span class="string">"ready to get/send data\0"</span><span class="keyword">; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">socket_write</span><span class="keyword">(</span><span class="default">$socket</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">//now you can read from...<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$line </span><span class="keyword">= </span><span class="default">trim</span><span class="keyword">(</span><span class="default">socket_read</span><span class="keyword">(</span><span class="default">$socket</span><span class="keyword">, </span><span class="default">MAXLINE</span><span class="keyword">));<br />
<br />
&nbsp;&nbsp;&nbsp; ...&nbsp; </span><span class="comment">// do some stuff, finaly close connection<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="35416""></a>
  <div class="note">
   <strong class="user">magicking89 at hotmail dot com</strong>
   <a href="#35416" class="date">30-Aug-2003 04:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
if you want to use a non block socket you must to use socket_last_error<br />
<br />
if(!socket_last_error($sc)){<br />
&nbsp;&nbsp; if($buffer=socket_read($sc,512,PHP_NORMAL_READ)){<br />
&nbsp;&nbsp; &nbsp;&nbsp; echo $buffer;<br />
&nbsp;&nbsp; }<br />
}<br />
<br />
if you use it your script wont take all your memory</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="33719""></a>
  <div class="note">
   <strong class="user">schst at php-tools dot de</strong>
   <a href="#33719" class="date">04-Jul-2003 06:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You may download a generic server class at <a href="http://www.php-tools.de" rel="nofollow" target="_blank">http://www.php-tools.de</a><br />
This class will accept the sockets read data from it and hands it to a callback function. Furthermore there are methods for connection handling included.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25456""></a>
  <div class="note">
   
   <a href="#25456" class="date">24-Sep-2002 11:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Windows telnet sends/recieves one character at a time. Try adding PHP_NORMAL_READ to the end of socket_read, that might help.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
