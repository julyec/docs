<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>SSL 上下文选项清单</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="context.ftp.html">? FTP 上下文选项</a></li>
      <li style="float: right;"><a href="context.phar.html">Phar 上下文（context）选项 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="context.html">上下文（Context）选项和参数</a></li>
    <li>SSL 上下文选项清单</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="context.ssl" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">SSL 上下文选项</h1>
  <p class="refpurpose"><span class="refname">SSL 上下文选项</span> &mdash; <span class="dc-title">SSL 上下文选项清单</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-context.ssl-description">
  <h3 class="title">说明</h3>
  <p class="para">
   <code class="literal">ssl://</code> 和 <code class="literal">tls://</code>
   传输协议上下文选项清单。
  </p>
 </div>


 <div class="refsect1 options" id="refsect1-context.ssl-options">
  <h3 class="title">可选项</h3>
  <p class="para">
   <dl>
    
     <dt id="context.ssl.peer-name">
      <code class="parameter">peer_name</code>
      <span class="type">string</span>
     </dt>

     <dd>

      <p class="para">
        要连接的服务器名称。如果未设置，那么服务器名称将根据打开 SSL 流的主机名称猜测得出。
      </p>
     </dd>

    
    
     <dt id="context.ssl.verify-peer">
      <code class="parameter">verify_peer</code>
      <span class="type">bool</span>
     </dt>

     <dd>

      <p class="para">
       是否需要验证 SSL 证书。
      </p>
      <p class="para">
       默认值为 <strong><code>true</code></strong>。
      </p>
     </dd>

    
    
       <dt id="context.ssl.verify-peer-name">
           <code class="parameter">verify_peer_name</code>
           <span class="type">bool</span>
       </dt>

       <dd>

           <p class="para">
            是否需要验证 peer name。
           </p>
           <p class="para">
               默认值为 <strong><code>true</code></strong>.
           </p>
       </dd>

    
    
     <dt id="context.ssl.allow-self-signed">
      <code class="parameter">allow_self_signed</code>
      <span class="type">bool</span>
     </dt>

     <dd>

      <p class="para">
       是否允许自签名证书。需要配合
       <a href="context.ssl.html#context.ssl.verify-peer" class="link"><code class="parameter">verify_peer</code></a> 参数使用（注：当 verify_peer 参数为 true 时才会根据 allow_self_signed 参数值来决定是否允许自签名证书）。
      </p>
      <p class="para">
       默认值为 <strong><code>false</code></strong>
      </p>
     </dd>

    
    
     <dt id="context.ssl.cafile">
      <code class="parameter">cafile</code>
      <span class="type">string</span>
     </dt>

     <dd>

      <p class="para">
       当设置 <code class="literal">verify_peer</code> 为 true 时，
       用来验证远端证书所用到的 CA 证书。
       本选项值为 CA 证书在本地文件系统的全路径及文件名。
      </p>
     </dd>

    
    
     <dt id="context.ssl.capath">
      <code class="parameter">capath</code>
      <span class="type">string</span>
     </dt>

     <dd>

      <p class="para">
       如果未设置 <code class="literal">cafile</code>，或者 <code class="literal">cafile</code> 所指的文件不存在时，
       会在 <code class="literal">capath</code> 所指定的目录搜索适用的证书。
       该目录必须是已经经过哈希处理的证书目录。
       （注：所谓 hashed certificate 目录是指使用类似 c_rehash 命令将目录中的 .pem 和 .crt 文件扫描并提取哈希码，然后根据此哈希码创建文件链接，以便于快速查找证书）
      </p>
     </dd>

    
    
     <dt id="context.ssl.local-cert">
      <code class="parameter">local_cert</code>
      <span class="type">string</span>
     </dt>

     <dd>

      <p class="para">
       本地证书路径。
       必须是 PEM 格式，并且包含本地的证书及私钥。
       也可以包含证书颁发者证书链。
       也可以通过 <code class="literal">local_pk</code> 指定包含私钥的独立文件。
      </p>
     </dd>

    
    
     <dt id="context.ssl.local-pk">
      <code class="parameter">local_pk</code>
      <span class="type">string</span>
     </dt>

     <dd>

      <p class="para">
       如果使用独立的文件来存储证书（<code class="literal">local_cert</code>）和私钥，
       那么使用此选项来指明私钥文件的路径。
      </p>
     </dd>

    
    
     <dt id="context.ssl.passphrase">
      <code class="parameter">passphrase</code>
      <span class="type">string</span>
     </dt>

     <dd>

      <p class="para">
       <code class="literal">local_cert</code> 文件的密码。
      </p>
     </dd>

    
    
     <dt id="context.ssl.verify-depth">
      <code class="parameter">verify_depth</code>
      <span class="type">int</span>
     </dt>

     <dd>

      <p class="para">
       如果证书链条层次太深，超过了本选项的设定值，则终止验证。
      </p>
      <p class="para">
       默认情况下不限制证书链条层次深度。
      </p>
     </dd>

    
    
     <dt id="context.ssl.ciphers">
      <code class="parameter">ciphers</code>
      <span class="type">string</span>
     </dt>

     <dd>

      <p class="para">
       设置可用的密码列表。
       可用的值参见： <a href="https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT" class="link external" title="Link : https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT">&raquo;&nbsp;ciphers(1)</a>。
      </p>
      <p class="para">
       默认值为 <code class="literal">DEFAULT</code>.
      </p>
     </dd>

    
    
     <dt id="context.ssl.capture-peer-cert">
      <code class="parameter">capture_peer_cert</code>
      <span class="type">bool</span>
     </dt>

     <dd>

      <p class="para">
       如果设置为 <strong><code>true</code></strong> 将会在上下文中创建 <code class="literal">peer_certificate</code> 选项，
       该选项中包含远端证书。
      </p>
     </dd>

    
    
     <dt id="context.ssl.capture-peer-cert-chain">
      <code class="parameter">capture_peer_cert_chain</code>
      <span class="type">bool</span>
     </dt>

     <dd>

      <p class="para">
       如果设置为 <strong><code>true</code></strong> 将会在上下文中创建 <code class="literal">peer_certificate_chain</code> 选项，
       该选项中包含远端证书链条。
      </p>
     </dd>

    
    
     <dt id="context.ssl.sni-enabled">
      <code class="parameter">SNI_enabled</code>
      <span class="type">bool</span>
     </dt>

     <dd>

      <p class="para">
       设置为 <strong><code>true</code></strong> 将启用服务器名称指示（server name indication）。 
       启用 SNI 将允许同一 IP 地址使用多个证书。
      </p>
     </dd>

    
    
     <dt id="context.ssl.disable-compression">
      <code class="parameter">disable_compression</code>
      <span class="type">bool</span>
     </dt>

     <dd>

      <p class="para">
       如果设置，则禁用 TLS 压缩，有助于减轻恶意攻击。
      </p>
     </dd>

    
    
     <dt id="context.ssl.peer-fingerprint">
      <code class="parameter">peer_fingerprint</code>
      <span class="type">string</span> | <span class="type">array</span>
     </dt>

     <dd>

      <p class="para">
       当远程服务器证书的摘要和指定的散列值不相同的时候，
       终止操作。
      </p>
      <p class="para">
       当使用 <span class="type">string</span> 时，
       会根据字符串的长度来检测所使用的散列算法："md5"（32 字节）还是"sha1"（40 字节）。
      </p>
      <p class="para">
       当使用 <span class="type">array</span> 时，
       数组的键表示散列算法名称，其对应的值是预期的摘要值。
      </p>
     </dd>

    
    
     <dt id="context.ssl.security-level">
      <code class="parameter">security_level</code>
      <span class="type">int</span>
     </dt>

     <dd>

      <p class="para">
       设置安全级别。如果未指定，则使用库默认安全级别。
       安全级别说明请参考 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_get_security_level.html" class="link external" title="Link : https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_get_security_level.html">&raquo;&nbsp;SSL_CTX_get_security_level(3)</a>。
      </p>
      <p class="para">
       从 PHP 7.2.0 和 OpenSSL 1.1.0 开始可用。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>

 
 <div class="refsect1 changelog" id="refsect1-context.ssl-changelog">
  <h3 class="title">更新日志</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>版本</th>
       <th>说明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>7.2.0</td>
       <td>
        添加了 <code class="parameter">security_level</code>。 需要 OpenSSL &gt;= 1.1.0。
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-context.ssl-notes">
  <h3 class="title">注释</h3>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <span class="simpara">
    因为 <code class="literal">ssl://</code> 是
    <a href="wrappers.http.html" class="link"><code class="literal">https://</code></a> 和
    <a href="wrappers.ftp.html" class="link"><code class="literal">ftps://</code></a> 的底层传输协议，
    所以，<code class="literal">ssl://</code> 的上下文选项也同样适用于
    <code class="literal">https://</code> 和 <code class="literal">ftps://</code> 上下文。
   </span>
  </p></blockquote>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <span class="simpara">
    PHP 必须联合 OpenSSL 0.9.8j 或以上版本编译才可以支持 SNI，
    同时也支持使用 <strong><code>OPENSSL_TLSEXT_SERVER_NAME</code></strong> 
    来探测 SNI 服务器名称。
   </span>
  </p></blockquote>
 </div>


 <div class="refsect1 seealso" id="refsect1-context.ssl-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><a href="context.socket.html" class="xref">套接字上下文选项</a></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="128002""></a>
  <div class="note">
   <strong class="user">tianyiw at vip dot qq dot com</strong>
   <a href="#128002" class="date">09-Dec-2022 04:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Enable SNI (Server Name Indication):<br />
PEM must be contains certificate and private key.<br />
<span class="default">&lt;?php<br />
$context </span><span class="keyword">= </span><span class="default">stream_context_create</span><span class="keyword">([<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'ssl' </span><span class="keyword">=&gt; [<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'SNI_enabled' </span><span class="keyword">=&gt; </span><span class="default">true</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'SNI_server_certs' </span><span class="keyword">=&gt; [<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'host1.com' </span><span class="keyword">=&gt; </span><span class="string">'/path/host1.com.pem'</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'host2.com' </span><span class="keyword">=&gt; </span><span class="string">'/path/host2.com.pem'</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ],<br />
&nbsp;&nbsp;&nbsp; ]<br />
]);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="126992""></a>
  <div class="note">
   <strong class="user">consatangmail dot com</strong>
   <a href="#126992" class="date">19-Apr-2022 03:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
recommended use "ssl://" transport.<br />
<br />
in php 5.5 ~ 7.1<br />
ssl:// transport = ssl_v2|ssl_v3|tls_v1.0|tls_v1.1|tls_v1.2<br />
tls:// transport = tls_v1.0<br />
<br />
after 7.2 ssl:// and tls:// transports is same<br />
php 7.2 ~ 7.3 = tls_v1.0|tls_v1.1|tls_v1.2<br />
php 7.4 ~ 8.1 = tls_v1.0|tls_v1.1|tls_v1.2|tls_v1.3</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="124605""></a>
  <div class="note">
   <strong class="user">gabri dot ns at gmail dot com</strong>
   <a href="#124605" class="date">13-Jan-2020 09:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
i usually download root CA certificate from https://curl.haxx.se/docs/caextract.html then put it as 'cafile' and it work almost all of the time.<br />
<br />
the only problem i'v ever found is when the server does not properly sending intermediete CA certificate, then, you must add it manually to the file.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="123325""></a>
  <div class="note">
   <strong class="user">mechtecs at gmail dot com</strong>
   <a href="#123325" class="date">09-Nov-2018 01:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to validate the server against a local certificate, which you already saved, to further validate the target server, you have to use a fullchain.pem. Then the verify_peer option will work. So just get the server certificate, and search the root CA's pem's and copy everything into a single file. For example:<br />
<br />
My certificate has the "GeoTrust TLS RSA CA G1" certificate in the chain, so you google that string. Go to the official digicert Geotrust page and download the "GeoTrustTLSRSACAG1.crt" certificate. Then you can use the following command to convert it into the pem format:<br />
openssl x509 -inform DER -in GeoTrustTLSRSACAG1.crt -out GeoTrustTLSRSACAG1.crt.pem -outform PEM</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="120278""></a>
  <div class="note">
   <strong class="user">Charlie</strong>
   <a href="#120278" class="date">05-Dec-2016 07:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I am unable to load a PEM that was generated with the stunnel tools. However, I am able to use PHP calls to generate a working PEM that is recognized both by stunnel and php, as outlined here:<br />
<br />
<a href="http://www.devdungeon.com/content/how-use-ssl-sockets-php" rel="nofollow" target="_blank">http://www.devdungeon.com/content/how-use-ssl-sockets-php</a><br />
<br />
This code fragment is now working for me, and with stunnel verify=4, both sides confirm the fingerprint. Oddly, if "tls://" is set below, then TLSv1 is forced, but using "ssl://" allows TLSv1.2:<br />
<br />
$stream_context = stream_context_create([ 'ssl' =&gt; [<br />
'local_cert'&nbsp; &nbsp; &nbsp; &nbsp; =&gt; '/path/to/key.pem',<br />
'peer_fingerprint'&nbsp; =&gt; openssl_x509_fingerprint(file_get_contents('/path/to/key.crt')),<br />
'verify_peer'&nbsp; &nbsp; &nbsp;&nbsp; =&gt; false,<br />
'verify_peer_name'&nbsp; =&gt; false,<br />
'allow_self_signed' =&gt; true,<br />
'verify_depth'&nbsp; &nbsp; &nbsp; =&gt; 0 ]]);<br />
<br />
$fp = stream_socket_client('ssl://ssl.server.com:12345',<br />
&nbsp;&nbsp; $errno, $errstr, 30, STREAM_CLIENT_CONNECT, $stream_context);<br />
fwrite($fp, "foo bar\n");<br />
while($line = fgets($fp, 8192)) echo $line;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="120265""></a>
  <div class="note">
   <strong class="user">Charlie</strong>
   <a href="#120265" class="date">02-Dec-2016 07:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It appears that "allow_self_signed" does not and cannot apply to the local_cert option.<br />
<br />
The stunnel verify=4 option, which verifies but ignores a CA, has no analog in these settings, which is unfortunate.<br />
<br />
Even more perplexingly, while the "openssl verify -CAfile" is successful, PHP appears unable to use the new ca/crt pair in any configuration.<br />
<br />
I did actually link my PHP against a copy of LibreSSL 2.3.8, but PHP oddly is unable to use TLS1.1 or 1.2. It does, however, enable EC secp521r1 (of which my native OpenSSL 0.9.8e is incapable).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="119844""></a>
  <div class="note">
   <strong class="user">website at meezaan dot net</strong>
   <a href="#119844" class="date">05-Sep-2016 01:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There is also a crypto_type context. In older versions this was crypto_method. This is referenced on <a href="http://php.net/manual/en/function.stream-socket-enable-crypto.php" rel="nofollow" target="_blank">http://php.net/manual/en/function.stream-socket-enable-crypto.php</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114269""></a>
  <div class="note">
   <strong class="user">borbas dot geri at gmail dot com</strong>
   <a href="#114269" class="date">31-Jan-2014 12:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I used this for Apple Push Notification Service.<br />
Passed in a local certificate filename `cert.pem` trough local_cert option. <br />
Worked fine, when invoked the script directly.<br />
<br />
But when I included/required the script from a different location, it stopped working, without any explicit error message.<br />
<br />
Resolved by passed in the full path for the file `&lt;FullPathTo&gt;cert.pem`.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="96328""></a>
  <div class="note">
   <strong class="user">Botjan kufca</strong>
   <a href="#96328" class="date">20-Feb-2010 11:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
CN_match works contrary to intuitive thinking. I came across this when I was developing SSL server implemented in PHP. I stated (in code): <br />
<br />
- do not allow self signed certs (works)<br />
- verify peer certs against CA cert (works)<br />
- verify the client's CN against CN_match (does not work), like this:<br />
<br />
stream_context_set_option($context, 'ssl', 'CN_match', '*.example.org');<br />
<br />
I presumed this would match any client with CN below .example.org domain.<br />
Unfortunately this is NOT the case. The option above does not do that.<br />
<br />
What it really does is this:<br />
- it takes client's CN and compares it to CN_match<br />
- IF CLIENT's CN CONTAINS AN ASTERISK like *.example.org, then it is matched against CN_match in wildcard matching fashion<br />
<br />
Examples to illustrate behaviour:<br />
(CNM = server's CN_match)<br />
(CCN = client's CN)<br />
<br />
- CNM=host.example.org, CCN=host.example.org ---&gt; OK<br />
- CNM=host.example.org, CCN=*.example.org ---&gt; OK<br />
- CNM=.example.org, CCN=*.example.org ---&gt; OK<br />
- CNM=example.org, CCN=*.example.org ---&gt; ERROR<br />
<br />
- CNM=*.example.org, CCN=host.example.org ---&gt; ERROR<br />
- CNM=*.example.org, CCN=*.example.org ---&gt; OK<br />
<br />
According to PHP sources I believe that the same applies if you are trying to act as Client and the server contains a wildcard certificate. If you set CN_match to myserver.example.org and server presents itself with *.example.org, the connection is allowed.<br />
<br />
Everything above applies to PHP version 5.2.12.<br />
I will supply a patch to support CN_match starting with asterisk.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
