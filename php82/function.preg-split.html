<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>通过一个正则表达式分隔字符串</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.preg-replace.html">? preg_replace</a></li>
      <li style="float: right;"><a href="book.ssdeep.html">ssdeep ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.pcre.html">PCRE 函数</a></li>
    <li>通过一个正则表达式分隔字符串</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.preg-split" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">preg_split</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_split</span> &mdash; <span class="dc-title">通过一个正则表达式分隔字符串</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-split-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_split</strong></span>(<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">string</span> <code class="parameter">$pattern</code></span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">string</span> <code class="parameter">$subject</code></span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">int</span> <code class="parameter">$limit</code><span class="initializer"> = -1</span></span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">int</span> <code class="parameter">$flags</code><span class="initializer"> = 0</span></span><br>): <span class="type"><span class="type">array</span>|<span class="type"><span class="type false">false</span></span></span></div>

  <p class="para rdfs-comment">
  通过一个正则表达式分隔给定字符串.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-split-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>
    
     <dt>
<code class="parameter">pattern</code></dt>

     <dd>

      <p class="para">
       用于搜索的模式，字符串形式。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">subject</code></dt>

     <dd>

      <p class="para">
       输入字符串
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">limit</code></dt>

     <dd>

      <p class="para">
      如果指定，将限制分隔得到的子串最多只有<code class="parameter">limit</code>个，返回的最后一个
      子串将包含所有剩余部分。<code class="parameter">limit</code>值为-1， 0或null时都代表&quot;不限制&quot;。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">flags</code></dt>

     <dd>

      <p class="para">
       <code class="parameter">flags </code>可以是任何下面标记的组合(以位或运算 <code class="literal">|</code> 组合)：
       <dl>
        
         <dt>
<strong><code>PREG_SPLIT_NO_EMPTY</code></strong></dt>

         <dd>

          <span class="simpara">
          如果这个标记被设置， <span class="function"><strong>preg_split()</strong></span> 将仅返回分隔后的非空部分。
          </span>
         </dd>

        
        
         <dt>
<strong><code>PREG_SPLIT_DELIM_CAPTURE</code></strong></dt>

         <dd>

          <span class="simpara">
          如果这个标记设置了，用于分隔的模式中的括号表达式将被捕获并返回。
          </span>
         </dd>

        
        
         <dt>
<strong><code>PREG_SPLIT_OFFSET_CAPTURE</code></strong></dt>

         <dd>

          <p class="para">
          如果这个标记被设置, 对于每一个出现的匹配返回时将会附加字符串偏移量. 
          注意：这将会改变返回数组中的每一个元素, 使其每个元素成为一个由第<code class="literal">0</code>
          个元素为分隔后的子串，第<code class="literal">1</code>个元素为该子串在<code class="parameter">subject</code>
          中的偏移量组成的数组。
          </p>
         </dd>

        
       </dl>

      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-split-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
  返回一个使用 <code class="parameter">pattern</code> 边界分隔 <code class="parameter">subject</code> 后得到
  的子串组成的数组， 或者在失败时返回 <strong><code>false</code></strong>。
  </p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.preg-split-errors">
  <h3 class="title">错误／异常</h3>
  <p class="para">
如果传递的正则表达式无法正常解析，会发出 <strong><code>E_WARNING</code></strong>。 
</p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-split-examples">
  <h3 class="title">示例</h3>
  <p class="para">
   <div class="example" id="">
    <p><strong>Example #1 <span class="function"><strong>preg_split()</strong></span>示例：获取搜索字符串的部分</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">//使用逗号或空格(包含" ", \r, \t, \n, \f)分隔短语<br /></span><span style="color: #0000BB">$keywords </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_split</span><span style="color: #007700">(</span><span style="color: #DD0000">"/[\s,]+/"</span><span style="color: #007700">, </span><span style="color: #DD0000">"hypertext language, programming"</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$keywords</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上示例会输出：</p></div> 
    <div class="example-contents screen">
<div class="cdata"><pre>
Array
(
    [0] =&gt; hypertext
    [1] =&gt; language
    [2] =&gt; programming
)
</pre></div>
    </div>
   </div>
  </p>
  <p class="para">
   <div class="example" id="">
    <p><strong>Example #2 将一个字符串分隔为组成它的字符</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$str </span><span style="color: #007700">= </span><span style="color: #DD0000">'string'</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$chars </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_split</span><span style="color: #007700">(</span><span style="color: #DD0000">'//'</span><span style="color: #007700">, </span><span style="color: #0000BB">$str</span><span style="color: #007700">, -</span><span style="color: #0000BB">1</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_SPLIT_NO_EMPTY</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$chars</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上示例会输出：</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
Array
(
    [0] =&gt; s
    [1] =&gt; t
    [2] =&gt; r
    [3] =&gt; i
    [4] =&gt; n
    [5] =&gt; g
)
</pre></div>
    </div>
   </div>
  </p>
  <p class="para">
   <div class="example" id="">
    <p><strong>Example #3 分隔一个字符串并获取每部分的偏移量</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$str </span><span style="color: #007700">= </span><span style="color: #DD0000">'hypertext language programming'</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$chars </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_split</span><span style="color: #007700">(</span><span style="color: #DD0000">'/ /'</span><span style="color: #007700">, </span><span style="color: #0000BB">$str</span><span style="color: #007700">, -</span><span style="color: #0000BB">1</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_SPLIT_OFFSET_CAPTURE</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$chars</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上示例会输出：</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
Array
(
    [0] =&gt; Array
        (
            [0] =&gt; hypertext
            [1] =&gt; 0
        )

    [1] =&gt; Array
        (
            [0] =&gt; language
            [1] =&gt; 10
        )

    [2] =&gt; Array
        (
            [0] =&gt; programming
            [1] =&gt; 19
        )

)
</pre></div>
    </div>
   </div>
  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.preg-split-notes">
  <h3 class="title">注释</h3>
  <div class="tip"><strong class="tip">Tip</strong>
   <p class="para">
   如果你不需要正则表达式功能，可以有更快(并且更简单)的选择比如 <span class="function"><a href="function.explode.html" class="function">explode()</a></span>
    或 <span class="function"><a href="function.str-split.html" class="function">str_split()</a></span>。
   </p>
  </div>
  <div class="tip"><strong class="tip">Tip</strong>
   <p class="para">
    如果没有成功匹配，将会返回一个数组，包含了单个元素，即输入的字符串。
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-split-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><a href="pcre.pattern.html" class="link">PCRE 模式</a></li>
    <li class="member"><span class="function"><a href="function.preg-quote.html" class="function" rel="rdfs-seeAlso">preg_quote()</a> - 转义正则表达式字符</span></li>
    <li class="member"><span class="function"><a href="function.implode.html" class="function" rel="rdfs-seeAlso">implode()</a> - 用字符串连接数组元素</span></li>
    <li class="member"><span class="function"><a href="function.preg-match.html" class="function" rel="rdfs-seeAlso">preg_match()</a> - 执行匹配正则表达式</span></li>
    <li class="member"><span class="function"><a href="function.preg-match-all.html" class="function" rel="rdfs-seeAlso">preg_match_all()</a> - 执行一个全局正则表达式匹配</span></li>
    <li class="member"><span class="function"><a href="function.preg-replace.html" class="function" rel="rdfs-seeAlso">preg_replace()</a> - 执行一个正则表达式的搜索和替换</span></li>
    <li class="member"><span class="function"><a href="function.preg-last-error.html" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - 返回最后一个PCRE正则执行产生的错误代码</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="127151""></a>
  <div class="note">
   <strong class="user">Walf</strong>
   <a href="#127151" class="date">01-Jun-2022 08:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using PREG_SPLIT_DELIM_CAPTURE without PREG_SPLIT_NO_EMPTY guarantees that all the odd-numbered keys in the result will contain the delimiters. This makes further processing more predictable, and empty strings can always be filtered out at the end.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="126520""></a>
  <div class="note">
   <strong class="user">dewi at dewimorgan dot com</strong>
   <a href="#126520" class="date">20-Oct-2021 07:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Beware that it is not safe to assume there are no empty values returned by PREG_SPLIT_NO_EMPTY, nor that you will see no delimiters if you use PREG_SPLIT_DELIM_CAPTURE, as there are some edge cases where these are not true.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment"># As expected, splitting a string by itself returns two empty strings:<br />
</span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">"/x/"</span><span class="keyword">, </span><span class="string">"x"</span><span class="keyword">));<br />
<br />
array (<br />
&nbsp; </span><span class="default">0 </span><span class="keyword">=&gt; </span><span class="string">''</span><span class="keyword">,<br />
&nbsp; </span><span class="default">1 </span><span class="keyword">=&gt; </span><span class="string">''</span><span class="keyword">,<br />
)<br />
<br />
</span><span class="comment"># But if we add PREG_SPLIT_NO_EMPTY, then instead of an empty array, we get the delimiter.<br />
</span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">"/x/"</span><span class="keyword">, </span><span class="string">"x"</span><span class="keyword">, </span><span class="default">PREG_SPLIT_NO_EMPTY</span><span class="keyword">));<br />
<br />
array (<br />
&nbsp; </span><span class="default">0 </span><span class="keyword">=&gt; </span><span class="string">'x'</span><span class="keyword">,<br />
)<br />
<br />
And if </span><span class="default">we </span><span class="keyword">try </span><span class="default">to split an </span><span class="keyword">empty </span><span class="default">string</span><span class="keyword">, </span><span class="default">then instead of an </span><span class="keyword">empty array, </span><span class="default">we get an </span><span class="keyword">empty </span><span class="default">string even with PREG_SPLIT_NO_EMPTY</span><span class="keyword">.<br />
</span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">"/x/"</span><span class="keyword">, </span><span class="string">""</span><span class="keyword">, </span><span class="default">PREG_SPLIT_NO_EMPTY</span><span class="keyword">));<br />
<br />
array (<br />
&nbsp; </span><span class="default">0 </span><span class="keyword">=&gt; </span><span class="string">''</span><span class="keyword">,<br />
)<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="124158""></a>
  <div class="note">
   <strong class="user">Hayley Watson</strong>
   <a href="#124158" class="date">01-Sep-2019 03:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Assuming you're using UTF-8, this function can be used to separate Unicode text into individual codepoints without the need for the multibyte extension.<br />
<br />
<span class="default">&lt;?php<br />
<br />
preg_split</span><span class="keyword">(</span><span class="string">'//u'</span><span class="keyword">, </span><span class="default">$text</span><span class="keyword">, -</span><span class="default">1</span><span class="keyword">, </span><span class="default">PREG_SPLIT_NO_EMPTY</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
The words "English", "Espa?ol", and "Русский" are all seven letters long. But strlen would report string lengths 7, 8 and 14, respectively. The preg_split above would return a seven-element array in all three cases. <br />
<br />
It splits '???' into the array ['?', '?', '?'] instead of the 9-character array that str_split($text) would produce.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="120149""></a>
  <div class="note">
   <strong class="user">php at haravikk dot me</strong>
   <a href="#120149" class="date">11-Nov-2016 03:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When using the PREG_SPLIT_OFFSET_CAPTURE option you will end up with all results in a single array, which is often undesirable as it means you then have to filter out any delimiters you wanted to check for but not keep.<br />
<br />
To get around this you can instead use preg_match_all() to perform the split. For comparison, here are two examples, both splitting around colon and semi-colon characters:<br />
<br />
<span class="default">&lt;?php $pieces_with_delimiters </span><span class="keyword">= </span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">'/[;:]/'</span><span class="keyword">, </span><span class="default">$input</span><span class="keyword">, -</span><span class="default">1</span><span class="keyword">, </span><span class="default">PREG_SPLIT_OFFSET_CAPTURE</span><span class="keyword">); </span><span class="default">?&gt;<br />
</span><br />
<span class="default">&lt;?php preg_match_all</span><span class="keyword">(</span><span class="string">'/([^;:]*)([;:]|$)/'</span><span class="keyword">, </span><span class="default">$input</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
list(, </span><span class="default">$pieces</span><span class="keyword">, </span><span class="default">$delimiters</span><span class="keyword">) = </span><span class="default">$matches ?&gt;<br />
</span><br />
The latter requires a more complex pattern, but produces a much more convenient set of results to work with, depending upon what you want to do with them.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="118326""></a>
  <div class="note">
   <strong class="user">canadian dot in dot exile at gmail dot com</strong>
   <a href="#118326" class="date">18-Nov-2015 12:27</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This regular expression will split a long string of words into an array of sub-strings, of some maximum length, but only on word-boundries.<br />
<br />
I use the reg-ex with preg_match_all(); but, I'm posting this example here (on the page for preg_split()) because that's where I looked when I wanted to find a way to do this.<br />
<br />
Hope it saves someone some time.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// example of a long string of words<br />
</span><span class="default">$long_string </span><span class="keyword">= </span><span class="string">'Your IP Address will be logged with the submitted note and made public on the PHP manual user notes mailing list. The IP address is logged as part of the notes moderation process, and won\'t be shown within the PHP manual itself.'</span><span class="keyword">;<br />
<br />
</span><span class="comment">// "word-wrap" at, for example, 60 characters or less<br />
</span><span class="default">$max_len </span><span class="keyword">= </span><span class="default">60</span><span class="keyword">;<br />
<br />
</span><span class="comment">// this regular expression will split $long_string on any sub-string of<br />
// 1-or-more non-word characters (spaces or punctuation)<br />
</span><span class="keyword">if(</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">"/.{1,</span><span class="keyword">{</span><span class="default">$max_len</span><span class="keyword">}</span><span class="string">}(?=\W+)/"</span><span class="keyword">, </span><span class="default">$long_string</span><span class="keyword">, </span><span class="default">$lines</span><span class="keyword">) !== </span><span class="default">False</span><span class="keyword">) {<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// $lines now contains an array of sub-strings, each will be approx.<br />
&nbsp;&nbsp;&nbsp; // $max_len characters - depending on where the last word ended and<br />
&nbsp;&nbsp;&nbsp; // the number of 'non-word' characters found after the last word<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">count</span><span class="keyword">(</span><span class="default">$lines</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]); </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"[</span><span class="default">$i</span><span class="string">] </span><span class="keyword">{</span><span class="default">$lines</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">][</span><span class="default">$i</span><span class="keyword">]}</span><span class="string">\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="116490""></a>
  <div class="note">
   <strong class="user">markac</strong>
   <a href="#116490" class="date">11-Jan-2015 04:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Split string into words.<br />
<br />
<span class="default">&lt;?php<br />
$string </span><span class="keyword">= </span><span class="string">'This - is a, very dirty "string" :-)'</span><span class="keyword">;<br />
<br />
</span><span class="comment">// split into words<br />
</span><span class="default">$wordlist </span><span class="keyword">= </span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">'/\W/'</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">PREG_SPLIT_NO_EMPTY</span><span class="keyword">);<br />
<br />
</span><span class="comment">// returns only words that have minimum 2 chars<br />
</span><span class="default">$wordlist </span><span class="keyword">= </span><span class="default">array_filter</span><span class="keyword">(</span><span class="default">$wordlist</span><span class="keyword">, function(</span><span class="default">$val</span><span class="keyword">) {<br />
&nbsp; return </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$val</span><span class="keyword">) &gt;= </span><span class="default">2</span><span class="keyword">;<br />
});<br />
<br />
</span><span class="comment">// print<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$wordlist</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Result:<br />
<br />
array (size=5)<br />
&nbsp; 0 =&gt; string 'This' (length=4)<br />
&nbsp; 1 =&gt; string 'is' (length=2)<br />
&nbsp; 3 =&gt; string 'very' (length=4)<br />
&nbsp; 4 =&gt; string 'dirty' (length=5)<br />
&nbsp; 5 =&gt; string 'string' (length=6)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114474""></a>
  <div class="note">
   <strong class="user">Miller</strong>
   <a href="#114474" class="date">24-Feb-2014 05:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is a function to truncate a string of text while preserving the whitespace (for instance, getting an excerpt from an article while maintaining newlines). It will not jive well with HTML, of course.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/**<br />
&nbsp;* Truncates a string of text by word count<br />
&nbsp;* @param string $text The text to truncate<br />
&nbsp;* @param int $max_words The maximum number of words<br />
&nbsp;* @return string The truncated text<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">limit_words </span><span class="keyword">(</span><span class="default">$text</span><span class="keyword">, </span><span class="default">$max_words</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$split </span><span class="keyword">= </span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">'/(\s+)/'</span><span class="keyword">, </span><span class="default">$text</span><span class="keyword">, -</span><span class="default">1</span><span class="keyword">, </span><span class="default">PREG_SPLIT_DELIM_CAPTURE</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$truncated </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">min</span><span class="keyword">(</span><span class="default">count</span><span class="keyword">(</span><span class="default">$split</span><span class="keyword">), </span><span class="default">$max_words</span><span class="keyword">*</span><span class="default">2</span><span class="keyword">); </span><span class="default">$i </span><span class="keyword">+= </span><span class="default">2</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$truncated </span><span class="keyword">.= </span><span class="default">$split</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">].</span><span class="default">$split</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">trim</span><span class="keyword">(</span><span class="default">$truncated</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="104618""></a>
  <div class="note">
   <strong class="user">david dot binovec at gmail dot com</strong>
   <a href="#104618" class="date">26-Jun-2011 06:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Limit = 1 may be confusing. The important thing is that in case of limit equals to 1 will produce only ONE substring. Ergo the only one substring will be the first one as well as the last one. Tnat the rest of the string (after the first delimiter) will be placed to the last substring. But last is the first and only one.<br />
<br />
<span class="default">&lt;?php<br />
<br />
$output </span><span class="keyword">= </span><span class="default">$preg_split</span><span class="keyword">(</span><span class="string">'(/ /)'</span><span class="keyword">, </span><span class="string">'1 2 3 4 5 6 7 8'</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">); <br />
<br />
echo </span><span class="default">$output</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">] </span><span class="comment">//will return whole string!;<br />
<br />
</span><span class="default">$output </span><span class="keyword">= </span><span class="default">$preg_split</span><span class="keyword">(</span><span class="string">'(/ /)'</span><span class="keyword">, </span><span class="string">'1 2 3 4 5 6 7 8'</span><span class="keyword">, </span><span class="default">2</span><span class="keyword">); <br />
<br />
echo </span><span class="default">$output</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">] </span><span class="comment">//will return 1;<br />
</span><span class="keyword">echo </span><span class="default">$output</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] </span><span class="comment">//will return '2 3 4 5 6 7 8';<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="104602""></a>
  <div class="note">
   <strong class="user">eric at clarinova dot com</strong>
   <a href="#104602" class="date">24-Jun-2011 03:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is another way to split a CamelCase string, which is a simpler expression than the one using lookaheads and lookbehinds: <br />
<br />
preg_split('/([[:upper:]][[:lower:]]+)/', $last, null, PREG_SPLIT_DELIM_CAPTURE|PREG_SPLIT_NO_EMPTY)<br />
<br />
It makes the entire CamelCased word the delimiter, then returns the delimiters (PREG_SPLIT_DELIM_CAPTURE) and omits the empty values between the delimiters (PREG_SPLIT_NO_EMPTY)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="101109""></a>
  <div class="note">
   <strong class="user">PhoneixSegovia at gmail dot com</strong>
   <a href="#101109" class="date">26-Nov-2010 04:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You must be caution when using lookbehind to a variable match.<br />
For example:<br />
'/(?&lt;!\\\)\r?\n)/'<br />
&nbsp;to match a new line when not \ is before it don't go as spected as it match \r as the lookbehind (becouse isn't a \) and is optional before \n.<br />
<br />
You must use this for example:<br />
'/((?&lt;!\\\|\r)\n)|((?&lt;!\\\)\r\n)/'<br />
That match a alone \n (not preceded by \r or \) or a \r\n not preceded by a \.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100729""></a>
  <div class="note">
   <strong class="user">Daniel Schroeder</strong>
   <a href="#100729" class="date">03-Nov-2010 03:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to split by a char, but want to ignore that char in case it is escaped, use a lookbehind assertion.
<br />

<br />
In this example a string will be split by ":" but "\:" will be ignored:
<br />

<br />
<span class="default">&lt;?php
<br />
$string</span><span class="keyword">=</span><span class="string">'a:b:c\:d'</span><span class="keyword">;
<br />
</span><span class="default">$array</span><span class="keyword">=</span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">'#(?&lt;!\\\)\:#'</span><span class="keyword">,</span><span class="default">$string</span><span class="keyword">);
<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">);
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
Results into:
<br />

<br />
Array
<br />
(
<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; a
<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; b
<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; c\:d
<br />
)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94238""></a>
  <div class="note">
   <strong class="user">jan dot sochor at icebolt dot info</strong>
   <a href="#94238" class="date">24-Oct-2009 03:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Sometimes PREG_SPLIT_DELIM_CAPTURE does strange results.<br />
<br />
<span class="default">&lt;?php<br />
$content </span><span class="keyword">= </span><span class="string">'&lt;strong&gt;Lorem ipsum dolor&lt;/strong&gt; sit &lt;img src="test.png" /&gt;amet &lt;span class="test" style="color:red"&gt;consec&lt;i&gt;tet&lt;/i&gt;uer&lt;/span&gt;.'</span><span class="keyword">;<br />
</span><span class="default">$chars </span><span class="keyword">= </span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">'/&lt;[^&gt;]*[^\/]&gt;/i'</span><span class="keyword">, </span><span class="default">$content</span><span class="keyword">, -</span><span class="default">1</span><span class="keyword">, </span><span class="default">PREG_SPLIT_NO_EMPTY </span><span class="keyword">| </span><span class="default">PREG_SPLIT_DELIM_CAPTURE</span><span class="keyword">);<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$chars</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>Produces:<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; Lorem ipsum dolor<br />
&nbsp;&nbsp;&nbsp; [1] =&gt;&nbsp; sit &lt;img src="test.png" /&gt;amet <br />
&nbsp;&nbsp;&nbsp; [2] =&gt; consec<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; tet<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; uer<br />
)<br />
<br />
So that the delimiter patterns are missing. If you wanna get these patters remember to use parentheses.<br />
<br />
<span class="default">&lt;?php<br />
$chars </span><span class="keyword">= </span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">'/(&lt;[^&gt;]*[^\/]&gt;)/i'</span><span class="keyword">, </span><span class="default">$content</span><span class="keyword">, -</span><span class="default">1</span><span class="keyword">, </span><span class="default">PREG_SPLIT_NO_EMPTY </span><span class="keyword">| </span><span class="default">PREG_SPLIT_DELIM_CAPTURE</span><span class="keyword">);<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$chars</span><span class="keyword">); </span><span class="comment">//parentheses added<br />
</span><span class="default">?&gt;<br />
</span>Produces:<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; &lt;strong&gt;<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; Lorem ipsum dolor<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; &lt;/strong&gt;<br />
&nbsp;&nbsp;&nbsp; [3] =&gt;&nbsp; sit &lt;img src="test.png" /&gt;amet <br />
&nbsp;&nbsp;&nbsp; [4] =&gt; &lt;span class="test" style="color:red"&gt;<br />
&nbsp;&nbsp;&nbsp; [5] =&gt; consec<br />
&nbsp;&nbsp;&nbsp; [6] =&gt; &lt;i&gt;<br />
&nbsp;&nbsp;&nbsp; [7] =&gt; tet<br />
&nbsp;&nbsp;&nbsp; [8] =&gt; &lt;/i&gt;<br />
&nbsp;&nbsp;&nbsp; [9] =&gt; uer<br />
&nbsp;&nbsp;&nbsp; [10] =&gt; &lt;/span&gt;<br />
&nbsp;&nbsp;&nbsp; [11] =&gt; .<br />
)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93907""></a>
  <div class="note">
   <strong class="user">php at dmi dot me dot uk</strong>
   <a href="#93907" class="date">06-Oct-2009 01:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To split a camel-cased string using preg_split() with lookaheads and lookbehinds:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">splitCamelCase</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">) {<br />
&nbsp; return </span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">'/(?&lt;=\\w)(?=[A-Z])/'</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92632""></a>
  <div class="note">
   <strong class="user">buzoganylaszlo at yahoo dot com</strong>
   <a href="#92632" class="date">01-Aug-2009 12:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Extending m.timmermans's solution, you can use the following code as a search expression parser:<br />
<br />
<span class="default">&lt;?php<br />
$search_expression </span><span class="keyword">= </span><span class="string">"apple bear \"Tom Cruise\" or 'Mickey Mouse' another word"</span><span class="keyword">;<br />
</span><span class="default">$words </span><span class="keyword">= </span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">"/[\s,]*\\\"([^\\\"]+)\\\"[\s,]*|" </span><span class="keyword">. </span><span class="string">"[\s,]*'([^']+)'[\s,]*|" </span><span class="keyword">. </span><span class="string">"[\s,]+/"</span><span class="keyword">, </span><span class="default">$search_expression</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">PREG_SPLIT_NO_EMPTY </span><span class="keyword">| </span><span class="default">PREG_SPLIT_DELIM_CAPTURE</span><span class="keyword">);<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$words</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
The result will be:<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; apple<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; bear<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; Tom Cruise<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; or<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; Mickey Mouse<br />
&nbsp;&nbsp;&nbsp; [5] =&gt; another<br />
&nbsp;&nbsp;&nbsp; [6] =&gt; word<br />
)<br />
<br />
1. Accepted delimiters: white spaces (space, tab, new line etc.) and commas.<br />
<br />
2. You can use either simple (') or double (") quotes for expressions which contains more than one word.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="91067""></a>
  <div class="note">
   <strong class="user">kenorb at gmail dot com</strong>
   <a href="#91067" class="date">23-May-2009 07:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you need convert function arguments without default default values and references, you can try this code:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $func_args </span><span class="keyword">= </span><span class="string">'$node, $op, $a3 = NULL, $form = array(), $a4 = NULL'<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$call_arg </span><span class="keyword">= </span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">'@(?&lt;func_arg&gt;\$[^,= ]+)@i'</span><span class="keyword">, </span><span class="default">$func_args</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$call_arg </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">(</span><span class="string">','</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">[</span><span class="string">'func_arg'</span><span class="keyword">]);<br />
</span><span class="default">?&gt;<br />
</span>Result: string = "$node,$op,$a3,$form,$a4"</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="89649""></a>
  <div class="note">
   <strong class="user">csaba at alum dot mit dot edu</strong>
   <a href="#89649" class="date">17-Mar-2009 01:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If the task is too complicated for preg_split, preg_match_all might come in handy, since preg_split is essentially a special case.<br />
<br />
I wanted to split a string on a certain character (asterisk), but only if it wasn't escaped (by a preceding backslash).&nbsp; Thus, I should ensure an even number of backslashes before any asterisk meant as a splitter.&nbsp; Look-behind in a regular expression wouldn't work since the length of the preceding backslash sequence can't be fixed.&nbsp; So I turned to preg_match_all:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// split a string at unescaped asterisks<br />
// where backslash is the escape character<br />
</span><span class="default">$splitter </span><span class="keyword">= </span><span class="string">"/\\*((?:[^\\\\*]|\\\\.)*)/"</span><span class="keyword">;<br />
</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$splitter</span><span class="keyword">, </span><span class="string">"*</span><span class="default">$string</span><span class="string">"</span><span class="keyword">, </span><span class="default">$aPieces</span><span class="keyword">, </span><span class="default">PREG_PATTERN_ORDER</span><span class="keyword">);<br />
</span><span class="default">$aPieces </span><span class="keyword">= </span><span class="default">$aPieces</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
<br />
</span><span class="comment">// $aPieces now contains the exploded string<br />
// and unescaping can be safely done on each piece<br />
</span><span class="keyword">foreach (</span><span class="default">$aPieces </span><span class="keyword">as </span><span class="default">$idx</span><span class="keyword">=&gt;</span><span class="default">$piece</span><span class="keyword">)<br />
&nbsp; </span><span class="default">$aPieces</span><span class="keyword">[</span><span class="default">$idx</span><span class="keyword">] = </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">"/\\\\(.)/s"</span><span class="keyword">, </span><span class="string">"$1"</span><span class="keyword">, </span><span class="default">$piece</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="51209""></a>
  <div class="note">
   <strong class="user">Steve</strong>
   <a href="#51209" class="date">23-Mar-2005 08:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
preg_split() behaves differently from perl's split() if the string ends with a delimiter. This perl snippet will print 5:
<br />

<br />
my @a = split(/ /, "a b c d e ");
<br />
print scalar @a;
<br />

<br />
The corresponding php code prints 6:
<br />

<br />
<span class="default">&lt;?php </span><span class="keyword">print </span><span class="default">count</span><span class="keyword">(</span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">"/ /"</span><span class="keyword">, </span><span class="string">"a b c d e "</span><span class="keyword">)); </span><span class="default">?&gt;
<br />
</span>
<br />
This is not necessarily a bug (nowhere does the documentation say that preg_split() behaves the same as perl's split()) but it might surprise perl programmers.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45982""></a>
  <div class="note">
   <strong class="user">jetsoft at iinet.net.au</strong>
   <a href="#45982" class="date">25-Sep-2004 08:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To clarify the "limit" parameter and the PREG_SPLIT_DELIM_CAPTURE option,
<br />

<br />
<span class="default">&lt;?php
<br />
$preg_split</span><span class="keyword">(</span><span class="string">'(/ /)'</span><span class="keyword">, </span><span class="string">'1 2 3 4 5 6 7 8'</span><span class="keyword">, </span><span class="default">4 </span><span class="keyword">,</span><span class="default">PREG_SPLIT_DELIM_CAPTURE </span><span class="keyword">);
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
returns:
<br />

<br />
('1', ' ', '2', ' ' , '3', ' ', '4 5 6 7 8')
<br />

<br />
So you actually get 7 array items not 4</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
