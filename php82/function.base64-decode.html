<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>对使用 MIME base64 编码的数据进行解码</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="ref.url.html">? URL 函数</a></li>
      <li style="float: right;"><a href="function.base64-encode.html">base64_encode ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.url.html">URL 函数</a></li>
    <li>对使用 MIME base64 编码的数据进行解码</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.base64-decode" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">base64_decode</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">base64_decode</span> &mdash; <span class="dc-title">对使用 MIME base64 编码的数据进行解码</span></p>

 </div>
 <div class="refsect1 description" id="refsect1-function.base64-decode-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>base64_decode</strong></span>(<span class="methodparam"><span class="type">string</span> <code class="parameter">$string</code></span>, <span class="methodparam"><span class="type">bool</span> <code class="parameter">$strict</code><span class="initializer"> = <strong><code>false</code></strong></span></span>): <span class="type"><span class="type">string</span>|<span class="type"><span class="type false">false</span></span></span></div>

  <p class="para rdfs-comment">
   对 base64 编码的 <code class="parameter">string</code> 进行解码。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.base64-decode-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>
    
     <dt>
<code class="parameter">string</code></dt>

     <dd>

      <p class="para">
       编码过的数据。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">strict</code></dt>

     <dd>

      <p class="para">
       当设置 <code class="parameter">strict</code> 为 <strong><code>true</code></strong> 时，一旦输入的数据超出了 base64 字母表，将返回 <strong><code>false</code></strong>。
       否则会静默丢弃无效的字符。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.base64-decode-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   返回解码后数据， 或者在失败时返回 <strong><code>false</code></strong>。返回的数据可能是二进制的。
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.base64-decode-examples">
  <h3 class="title">示例</h3>
  <p class="para">
   <div class="example" id="">
    <p><strong>Example #1 <span class="function"><strong>base64_decode()</strong></span> 示例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$str </span><span style="color: #007700">= </span><span style="color: #DD0000">'VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw=='</span><span style="color: #007700">;<br />echo </span><span style="color: #0000BB">base64_decode</span><span style="color: #007700">(</span><span style="color: #0000BB">$str</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上示例会输出：</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
This is an encoded string
</pre></div>
    </div>
   </div>
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.base64-decode-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.base64-encode.html" class="function" rel="rdfs-seeAlso">base64_encode()</a> - 使用 MIME base64 对数据进行编码</span></li>
    <li class="member">
     <a href="http://www.faqs.org/rfcs/rfc2045" class="link external" title="Link : http://www.faqs.org/rfcs/rfc2045">&raquo;&nbsp;RFC 2045</a> 的 6.8 章节。
     </li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="124020""></a>
  <div class="note">
   <strong class="user">user at sfdsfd dot com</strong>
   <a href="#124020" class="date">07-Jul-2019 08:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
function is_base64($str){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if($str === base64_encode(base64_decode($str))){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return true;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return false;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
---------------------------------------------------------------------------<br />
---------------------------------------------------------------------------<br />
---------------------------------------------------------------------------<br />
<br />
&nbsp;&nbsp;&nbsp; $str = 'VGhpcyBpcyBiYXNlNjQgZW5jb2RlIHN0cmluZw==';<br />
<br />
&nbsp;&nbsp;&nbsp; if(is_base64($str)){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; print base64_decode($str);<br />
&nbsp;&nbsp;&nbsp; }</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="118801""></a>
  <div class="note">
   <strong class="user">markandrewslade at gmail dot com</strong>
   <a href="#118801" class="date">08-Feb-2016 04:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The docs don't make this explicitly clear, but if you omit `$strict` or set it to `false` then invalid characters in the encoded input will be silently ignored.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">echo </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="string">'VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw=='</span><span class="keyword">); </span><span class="comment">// "This is an encoded string"<br />
</span><span class="keyword">echo </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="string">'$VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw=='</span><span class="keyword">); </span><span class="comment">// "This is an encoded string"<br />
</span><span class="keyword">echo </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="string">'$VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw=='</span><span class="keyword">, </span><span class="default">true</span><span class="keyword">); </span><span class="comment">// false<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="118244""></a>
  <div class="note">
   <strong class="user">walf</strong>
   <a href="#118244" class="date">02-Nov-2015 06:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Base64 for URL parameters/filenames, that adhere to RFC 4648.<br />
Defaults to dropping the padding on encode since it's not required for decoding, and keeps the URL free of % encodings.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">base64url_encode</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pad </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$data </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(array(</span><span class="string">'+'</span><span class="keyword">, </span><span class="string">'/'</span><span class="keyword">), array(</span><span class="string">'-'</span><span class="keyword">, </span><span class="string">'_'</span><span class="keyword">), </span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; if (!</span><span class="default">$pad</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$data </span><span class="keyword">= </span><span class="default">rtrim</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">, </span><span class="string">'='</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$data</span><span class="keyword">;<br />
}<br />
function </span><span class="default">base64url_decode</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">str_replace</span><span class="keyword">(array(</span><span class="string">'-'</span><span class="keyword">, </span><span class="string">'_'</span><span class="keyword">), array(</span><span class="string">'+'</span><span class="keyword">, </span><span class="string">'/'</span><span class="keyword">), </span><span class="default">$data</span><span class="keyword">));<br />
}</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="105512""></a>
  <div class="note">
   <strong class="user">nicolem2005 at gmail dot com</strong>
   <a href="#105512" class="date">23-Aug-2011 05:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
base64_decode seems to fail when decoding big files/strings. I had an issue decoding a 7MB image file. Here is a solution that worked for me:<br />
<br />
$decodedstring=base64_decode(chunk_split($encodedstring));</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102113""></a>
  <div class="note">
   <strong class="user">winkelnkemper at googlemail dot com</strong>
   <a href="#102113" class="date">27-Jan-2011 04:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to save data that is derived from a Javascript canvas.toDataURL() function, you have to convert blanks into plusses. If you do not do that, the decoded data is corrupted:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; $encodedData </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">' '</span><span class="keyword">,</span><span class="string">'+'</span><span class="keyword">,</span><span class="default">$encodedData</span><span class="keyword">);<br />
&nbsp; </span><span class="default">$decocedData </span><span class="keyword">= </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$encodedData</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92980""></a>
  <div class="note">
   <strong class="user">martinstaemmler at gmx dot net</strong>
   <a href="#92980" class="date">17-Aug-2009 09:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had some trouble trying to let base64_decode decode base64-strings longer than ~5k chars.
<br />

<br />
The base64-decoding function is a homomorphism between modulo 4 and modulo 3-length segmented strings. That motivates a divide and conquer approach: Split the encoded string into substrings counting modulo 4 chars, then decode each substring and concatenate all of them.
<br />

<br />
Then instead of 
<br />

<br />
<span class="default">&lt;?php $decoded </span><span class="keyword">= </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">); </span><span class="default">?&gt;
<br />
</span>
<br />
for big $encoded strings, it's saver to use
<br />

<br />
<span class="default">&lt;?php
<br />
$decoded </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">;
<br />
for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">ceil</span><span class="keyword">(</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">)/</span><span class="default">256</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">++)
<br />
&nbsp;&nbsp; </span><span class="default">$decoded </span><span class="keyword">= </span><span class="default">$decoded </span><span class="keyword">. </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">,</span><span class="default">$i</span><span class="keyword">*</span><span class="default">256</span><span class="keyword">,</span><span class="default">256</span><span class="keyword">));
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
where 256 can be replaced by a sufficiently small modulo 4 natural.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92147""></a>
  <div class="note">
   <strong class="user">dimagolov at yahoo dot com</strong>
   <a href="#92147" class="date">10-Jul-2009 11:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is function to decode Base 62 (see <a href="http://en.wikipedia.org/wiki/Base_62" rel="nofollow" target="_blank">http://en.wikipedia.org/wiki/Base_62</a>) string to number. It is used by MTA in message id, e.g. by Exim<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">base62_decode</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ret</span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i</span><span class="keyword">= </span><span class="default">0</span><span class="keyword">, </span><span class="default">$l</span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">); </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$l</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">= </span><span class="default">ord</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">ctype_digit</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">-= </span><span class="default">ord</span><span class="keyword">(</span><span class="string">'0'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">ctype_upper</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">-= </span><span class="default">ord</span><span class="keyword">(</span><span class="string">'A'</span><span class="keyword">) - </span><span class="default">10</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">ctype_lower</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">-= </span><span class="default">ord</span><span class="keyword">(</span><span class="string">'a'</span><span class="keyword">) - </span><span class="default">36</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret</span><span class="keyword">= </span><span class="default">$ret </span><span class="keyword">* </span><span class="default">62 </span><span class="keyword">+ </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$ret</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90199""></a>
  <div class="note">
   <strong class="user">mcalwell</strong>
   <a href="#90199" class="date">09-Apr-2009 09:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had a problem testing whether an imap message body was base64 encoded on a pre 5.2.* server.&nbsp; I had been using this function on a post 5.2 server.<br />
<br />
I found that the function imap_base64() returns FALSE on failing to decode a string, and that I could use that to check instead.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if(</span><span class="default">imap_base64</span><span class="keyword">(</span><span class="default">$body</span><span class="keyword">)) </span><span class="default">$body </span><span class="keyword">= </span><span class="default">imap_base64</span><span class="keyword">(</span><span class="default">$body</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87442""></a>
  <div class="note">
   <strong class="user">alvaro at demogracia dot com</strong>
   <a href="#87442" class="date">05-Dec-2008 01:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can do partial decoding (e.g. from buffered input streams) if you choose a chunk length that is multiple of 4:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$encoded </span><span class="keyword">= </span><span class="default">base64_encode</span><span class="keyword">(</span><span class="string">'The quick brown fox jumps over the lazy dog'</span><span class="keyword">);<br />
for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">=</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">$len</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">+=</span><span class="default">4</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">base64_decode</span><span class="keyword">( </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">, </span><span class="default">4</span><span class="keyword">) );<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
4 encoded chars represent 3 original chars. The "=" character is used as padding.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84349""></a>
  <div class="note">
   <strong class="user">twm at twmacinta dot com</strong>
   <a href="#84349" class="date">09-Jul-2008 08:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To follow up on Starson's post, PHP was changed to no longer treat a space as if it were a plus sign in CVS revision 1.43.2.1, which corresponds to PHP 5.1.0.&nbsp; You can see what happened with a diff to branch point 1.43 at:<br />
<br />
<a href="http://cvs.php.net/viewvc.cgi/php-src/ext/standard/base64.c" rel="nofollow" target="_blank">http://cvs.php.net/viewvc.cgi/php-src/ext/standard/base64.c</a><br />
<br />
The CVS log indicates that this change was made to fix bug #34214 (base64_decode() does not properly ignore whitespace).<br />
<br />
It would seem from the comment preceding the code which was removed that the treatment of the space as if it were the plus sign was actually intentional at one time:<br />
<br />
&nbsp;&nbsp;&nbsp; When Base64 gets POSTed, all pluses are interpreted as spaces.<br />
&nbsp;&nbsp;&nbsp; This line changes them back.&nbsp; It's not exactly the Base64 spec,<br />
&nbsp;&nbsp;&nbsp; but it is completely compatible with it (the spec says that spaces<br />
&nbsp;&nbsp;&nbsp; are invalid).&nbsp; This will also save many people considerable<br />
&nbsp;&nbsp;&nbsp; headache.<br />
<br />
&nbsp;&nbsp;&nbsp; if (ch == ' ') ch = '+';<br />
<br />
However, RFC 3548 states that characters not in the Base64 alphabet should either be ignored or cause the implementation to reject the encoding and RFC 2045 says they should be ignored.&nbsp; So the original code was unfortunately not fully compatible with the spec or other implementations.&nbsp; It may have also masked problems with code not properly escaping POST variables.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81425""></a>
  <div class="note">
   <strong class="user">debug</strong>
   <a href="#81425" class="date">27-Feb-2008 12:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
@morgangalpin att gmail dotty com<br />
<br />
A better implementation would be the following regular expression:<br />
<br />
^[a-zA-Z0-9/+]*={0,2}$<br />
<br />
Which will also detect the usage of = or == at the end of the string (and only end).<br />
<br />
If this regex isn't following proper RFC guidelines, please comment on it.<br />
<br />
A function geared specifically toward this:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">is_base64_encoded</span><span class="keyword">()<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'%^[a-zA-Z0-9/+]*={0,2}$%'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">TRUE</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">FALSE</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; };<br />
<br />
</span><span class="default">is_base64_encoded</span><span class="keyword">(</span><span class="string">"iash21iawhdj98UH3"</span><span class="keyword">); </span><span class="comment">// true<br />
</span><span class="default">is_base64_encoded</span><span class="keyword">(</span><span class="string">"#iu3498r"</span><span class="keyword">); </span><span class="comment">// false<br />
</span><span class="default">is_base64_encoded</span><span class="keyword">(</span><span class="string">"asiudfh9w=8uihf"</span><span class="keyword">); </span><span class="comment">// false<br />
</span><span class="default">is_base64_encoded</span><span class="keyword">(</span><span class="string">"a398UIhnj43f/1!+sadfh3w84hduihhjw=="</span><span class="keyword">); </span><span class="comment">// true<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79098""></a>
  <div class="note">
   <strong class="user">zmorris at zsculpt dot com</strong>
   <a href="#79098" class="date">10-Nov-2007 02:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is a drop-in replacement for base64_decode(), based on a faster version of morgangalpin's code:
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="comment">// workaround for bug in php 4.3.11 through 4.4.7, 5.1.2 through 5.2.4 and perhaps others (<a href="http://bugs.php.net/bug.php?id=37244" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=37244</a>)
<br />
</span><span class="keyword">function&nbsp; &nbsp; </span><span class="default">base64_decode_fix</span><span class="keyword">( </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$strict </span><span class="keyword">= </span><span class="default">false </span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; if( </span><span class="default">$strict </span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if( </span><span class="default">preg_match</span><span class="keyword">( </span><span class="string">'![^a-zA-Z0-9/+=]!'</span><span class="keyword">, </span><span class="default">$data </span><span class="keyword">) )
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return( </span><span class="default">false </span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; 
<br />
&nbsp;&nbsp;&nbsp; return( </span><span class="default">base64_decode</span><span class="keyword">( </span><span class="default">$data </span><span class="keyword">) );
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71583""></a>
  <div class="note">
   <strong class="user">Tom</strong>
   <a href="#71583" class="date">06-Dec-2006 10:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function supports "base64url" as described in Section 5 of RFC 4648, "Base 64 Encoding with URL and Filename Safe Alphabet"<br />
<br />
&nbsp;&nbsp;&nbsp; <span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">base64url_decode</span><span class="keyword">(</span><span class="default">$base64url</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$base64 </span><span class="keyword">= </span><span class="default">strtr</span><span class="keyword">(</span><span class="default">$base64url</span><span class="keyword">, </span><span class="string">'-_'</span><span class="keyword">, </span><span class="string">'+/'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$plainText </span><span class="keyword">= </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$base64</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return (</span><span class="default">$plainText</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69747""></a>
  <div class="note">
   <strong class="user">Starson</strong>
   <a href="#69747" class="date">19-Sep-2006 06:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To expand on Jes' post:<br />
<br />
The change took place between 5.0.5 and 5.1.0.&nbsp; Exactly where I don't know or care.<br />
<br />
In short php &lt;= 5.0.5's base64_decode( $string ) will assume that a space is meant to be a + sign where php &gt;= 5.1.0's base64_decode( $string ) will no longer make that assumption.&nbsp; I did not see this noted in the change log.<br />
<br />
Please note that, as of this writing, mb_convert_encoding( $string, "UTF-8", "BASE64" ) still behaves as base64_decode( $string ) did in php &lt;= 5.0.5 regardless of the version of php you are running.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="38479""></a>
  <div class="note">
   <strong class="user">tobias at silverxnet dot de</strong>
   <a href="#38479" class="date">23-Dec-2003 12:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I was wondering how to decode attached images within mails. Basically they are mostly JPEG files, so it was obviously to write a function that decodes JPEG images.
<br />
I guess the plainest way to do so was the following:
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">base64_to_jpeg</span><span class="keyword">( </span><span class="default">$inputfile</span><span class="keyword">, </span><span class="default">$outputfile </span><span class="keyword">) {
<br />
&nbsp; </span><span class="comment">/* read data (binary) */
<br />
&nbsp; </span><span class="default">$ifp </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">( </span><span class="default">$inputfile</span><span class="keyword">, </span><span class="string">"rb" </span><span class="keyword">);
<br />
&nbsp; </span><span class="default">$imageData </span><span class="keyword">= </span><span class="default">fread</span><span class="keyword">( </span><span class="default">$ifp</span><span class="keyword">, </span><span class="default">filesize</span><span class="keyword">( </span><span class="default">$inputfile </span><span class="keyword">) );
<br />
&nbsp; </span><span class="default">fclose</span><span class="keyword">( </span><span class="default">$ifp </span><span class="keyword">);
<br />
&nbsp; </span><span class="comment">/* encode &amp; write data (binary) */
<br />
&nbsp; </span><span class="default">$ifp </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">( </span><span class="default">$outputfile</span><span class="keyword">, </span><span class="string">"wb" </span><span class="keyword">);
<br />
&nbsp; </span><span class="default">fwrite</span><span class="keyword">( </span><span class="default">$ifp</span><span class="keyword">, </span><span class="default">base64_decode</span><span class="keyword">( </span><span class="default">$imageData </span><span class="keyword">) );
<br />
&nbsp; </span><span class="default">fclose</span><span class="keyword">( </span><span class="default">$ifp </span><span class="keyword">);
<br />
&nbsp; </span><span class="comment">/* return output filename */
<br />
&nbsp; </span><span class="keyword">return( </span><span class="default">$outputfile </span><span class="keyword">);
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
This function decodes the given inputfile (a filename!) and saves it to the given outputfile (a filename as well) and then returns the output filename for further usage (e.g. redirect, imagejpeg() and so on).
<br />
I thought that might be helpful.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31316""></a>
  <div class="note">
   <strong class="user">Klaus Fehrenbacher</strong>
   <a href="#31316" class="date">17-Apr-2003 04:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
this script can correct the bug
<br />

<br />
<span class="default">&lt;?php
<br />
$enc </span><span class="keyword">= </span><span class="default">chunk_split</span><span class="keyword">(</span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'!\015\012|\015|\012!'</span><span class="keyword">,</span><span class="string">''</span><span class="keyword">,</span><span class="default">$enc</span><span class="keyword">));
<br />
</span><span class="default">$enc </span><span class="keyword">= </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$enc</span><span class="keyword">);
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="20080""></a>
  <div class="note">
   <strong class="user">nsayer at kfu dot com</strong>
   <a href="#20080" class="date">21-Mar-2002 01:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I used to do uudecode as a C module, but I've discovered a really fast way to do it in PHP. Here it is:
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">uudecode</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">) {
<br />
&nbsp; </span><span class="default">$b64chars</span><span class="keyword">=</span><span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
<br />
abcdefghijklmnopqrstuvwxyz0123456789+/"</span><span class="keyword">;
<br />

<br />
&nbsp; </span><span class="default">$encode </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">"/^./m"</span><span class="keyword">,</span><span class="string">""</span><span class="keyword">,</span><span class="default">$encode</span><span class="keyword">);
<br />
&nbsp; </span><span class="default">$encode </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">"/\n/m"</span><span class="keyword">,</span><span class="string">""</span><span class="keyword">,</span><span class="default">$encode</span><span class="keyword">);
<br />
&nbsp; for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">++) {
<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$encode</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] == </span><span class="string">'`'</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$encode</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="string">' '</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$encode</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="default">$b64chars</span><span class="keyword">[</span><span class="default">ord</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">])-</span><span class="default">32</span><span class="keyword">];
<br />
&nbsp; }
<br />

<br />
&nbsp; while(</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">) % </span><span class="default">4</span><span class="keyword">)
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$encode </span><span class="keyword">.= </span><span class="string">"="</span><span class="keyword">;
<br />

<br />
&nbsp; return </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">);
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
This is the PHP equivalent to perl's unpack("u",___). That is, you need to strip the 'begin' and 'end' lines from the typical uuencoded file.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
