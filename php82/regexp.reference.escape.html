<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>转义序列(反斜线)</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="regexp.reference.meta.html">? 元字符</a></li>
      <li style="float: right;"><a href="regexp.reference.unicode.html">Unicode 字符属性 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="reference.pcre.pattern.syntax.html">PCRE 正则语法</a></li>
    <li>转义序列(反斜线)</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="regexp.reference.escape" class="section">
  <h2 class="title">转义序列(反斜线)</h2>
  <p class="para">
  反斜线有多种用法。首先，如果紧接着是一个非字母数字字符，表明取消
  该字符所代表的特殊涵义。这种将反斜线作为转义字符的用法在字符类
  内部和外部都可用。
  </p>
  <p class="para">
  比如，如果你希望匹配一个 &quot;*&quot; 字符，就需要在模式中写为 &quot;\*&quot;。
  这适用于一个字符在不进行转义会有特殊含义的情况下。 但是，
  对于非数字字母的字符，总是在需要其进行原文匹配的时候在它前面增加一个反斜线，
  来声明它代表自己，这是安全的。如果要匹配一个反斜线，那么在模式中使用 "\\"。
  </p>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
   反斜线在单引号和双引号 PHP <a href="language.types.string.html#language.types.string.syntax" class="link">字符串</a>
   中都有特殊含义。因此要匹配一个反斜线 \，正则表达式写法是 \\，
   然后 PHP 代码中需要转义写成 &quot;\\\\&quot; 或 &#039;\\\\&#039;。
   </p>
  </p></blockquote>
  <p class="para">
  如果一个模式被使用 <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_EXTENDED</a> 选项编译，
  模式中的空白字符(除了字符类中的)和未转义的#到行末的所有字符都会被忽略。
  要在这种情况下使用空白字符或者#，就需要对其进行转义。
  </p>
  <p class="para">
  反斜线的第二种用途提供了一种对非打印字符进行可见编码的控制手段。
  除了二进制的 0 会终结一个模式外，并不会严格的限制非打印字符(自身)的出现，
  但是当一个模式以文本编辑器的方式编辑准备的时候，
  使用下面的转义序列相比使用二进制字符会更加容易：
  </p>
  <p class="para">
   <dl>
    
     <dt>
<em class="emphasis">\a</em></dt>

     <dd>

      <span class="simpara">响铃字符(十六进制 07)</span>
     </dd>

    
    
     <dt>
<em class="emphasis">\cx</em></dt>

     <dd>

      <span class="simpara">&quot;control-x&quot;，x 是任意字符</span>
     </dd>

    
    
     <dt>
<em class="emphasis">\e</em></dt>

     <dd>

      <span class="simpara">转义 (十六进制 1B)</span>
     </dd>

    
    
     <dt>
<em class="emphasis">\f</em></dt>

     <dd>

      <span class="simpara">换页 (十六进制 0C)</span>
     </dd>

    
    
     <dt>
<em class="emphasis">\n</em></dt>

     <dd>

      <span class="simpara">换行 (十六进制 0A)</span>
     </dd>

    
    
     <dt>
<em class="emphasis">\p{xx}</em></dt>

     <dd>

      <span class="simpara">
      一个符合 xx 属性的字符，详细查看<a href="regexp.reference.unicode.html" class="link">unicode properties</a> 属性
      </span>
     </dd>

    
    
     <dt>
<em class="emphasis">\P{xx}</em></dt>

     <dd>

      <span class="simpara">
      一个不符合xx属性的字符，详细查看<a href="regexp.reference.unicode.html" class="link">unicode properties</a> 属性
      </span>
     </dd>

    
    
     <dt>
<em class="emphasis">\r</em></dt>

     <dd>

      <span class="simpara">回车 (十六进制 0D)</span>
     </dd>

    
    
     <dt>
<em class="emphasis">\R</em></dt>

     <dd>

      <span class="simpara">换行符：能匹配 \n、\r、\r\n</span>
     </dd>

    
    
     <dt>
<em class="emphasis">\t</em></dt>

     <dd>

      <span class="simpara">水平制表符 tab (十六进制 09)</span>
     </dd>

    
    
     <dt>
<em class="emphasis">\xhh</em></dt>

     <dd>

      <span class="simpara">
      hh 十六进制编码的字符
      </span>
     </dd>

    
    
     <dt>
<em class="emphasis">\ddd</em></dt>

     <dd>

      <span class="simpara">ddd八进制编码的字符，或者后向引用</span>
     </dd>

    
   </dl>

  </p>
  <p class="para">
  <code class="literal">\cx</code>的确切效果如下： 如果<code class="literal">x</code>是一个小写字母，它被转换为大写。接着，
  将字符的第6位(十六进制 40，右数第一个位为第0位)取反。
  比如<code class="literal">\cz</code>成为十六进制的1A，<code class="literal">\c{</code>成为十六进制3B，
  <code class="literal">\c;</code>成为十六进制7B。
  </p>
  <p class="para">
  在"<code class="literal">\x</code>"后面，读取两个十六进制数(字母可以是大写或小写)。
  在<em class="emphasis">UTF-8模式</em>，
  "<code class="literal">\x{...}</code>"允许使用， 花括号内的内容是十六进制有效数字。
  它将给出的十六进制数字解释为 UTF-8 字符代码。原来的十六进制转义序列，
  <code class="literal">\xhh</code>，
  匹配一个双字节的UTF-8字符，如果它的值大于127
  </p>
  <p class="para">
  在"<code class="literal">\0</code>"之后， 读取两个八进制数。所有情况下，如果数少于2个，则直接使用。
  序列 "<code class="literal">\0\x\07</code>" 指定了两个二进制 0 紧跟着一个 BEL 字符。
  请确保初始的 0 之后的两个数字是合法的八进制数。
  </p>
  <p class="para">
  处理一个反斜线紧跟着的不是0的数字的情况比较复杂。在字符类外部，
  PCRE 读取它并以十进制读取紧随其后的数字。 如果数值小于 10，
  或者之前捕获到了该数字能够代表的左括号(子组)，
  整个数字序列被认为是<em class="emphasis">后向引用</em>。后向引用如何工作在后面描述，
  接下来就会讨论括号子组。
  </p>
  <p class="para">
  在一个字符类里面，或者十进制数大于 9 并且没有那么多的子组被捕获，
  PCRE 重新读取反斜线后的第三个 8 进制数字，并且从最低的 8 位生成单字节值。
  任何的后续数字都代表它们自身。例如：
  </p>
  <p class="para">
   <dl>
    
     <dt>
<em class="emphasis">\040</em></dt>

     <dd>
<span class="simpara">空格的另外一种用法</span></dd>

    
    
     <dt>
<em class="emphasis">\40</em></dt>

     <dd>

      <span class="simpara">
      当提供了少于40个子组时也认为是空格。
      </span>
     </dd>

    
    
     <dt>
<em class="emphasis">\7</em></dt>

     <dd>
<span class="simpara">始终是后向引用</span></dd>

    
    
     <dt>
<em class="emphasis">\11</em></dt>

     <dd>

      <span class="simpara">
      可能是后向引用，也可能是制表符
      </span>
     </dd>

    
    
     <dt>
<em class="emphasis">\011</em></dt>

     <dd>
<span class="simpara">总是一个制表符</span></dd>

    
    
     <dt>
<em class="emphasis">\0113</em></dt>

     <dd>
<span class="simpara">一个制表符紧跟着一个3(因为每次最多只读取3个8进制位</span></dd>

    
    
     <dt>
<em class="emphasis">\113</em></dt>

     <dd>

      <span class="simpara">
      八进制113代表的字符(since there
       can be no more than 99 back references)
      </span>
     </dd>

    
    
     <dt>
<em class="emphasis">\377</em></dt>

     <dd>
<span class="simpara">8进制377是10进制255， 因此代表一个全1的字符</span></dd>

    
    
     <dt>
<em class="emphasis">\81</em></dt>

     <dd>

      <span class="simpara">
      一个后向引用或者一个二进制 0 紧跟着两个数字 8 和 1(因为8不是8进制有效数字)
      </span>
     </dd>

    
   </dl>

  </p>
  <p class="para">
  注意，八进制值的 100 或者更大的值必须没有前置的0引导，
  因为每次最多读取3个8进制位.
  </p>
  <p class="para">
  所有序列定义的单字节值都可以在字符类内部或外部使用。另外，在字符类中,
  序列 "<code class="literal">\b</code>" 解释为退格字符(hex 08)。
  字符类外它又有不同的意义(下面有描述)。
  </p>
  <p class="para">
  反斜线的第三种用法是用来描述特定的字符类：
  </p>
  <p class="para">
   <dl>
    
     <dt>
<em class="emphasis">\d</em></dt>

     <dd>
<span class="simpara">任意十进制数字</span></dd>

    
    
     <dt>
<em class="emphasis">\D</em></dt>

     <dd>
<span class="simpara">任意非十进制数字</span></dd>

    
    
     <dt>
<em class="emphasis">\h</em></dt>

     <dd>
<span class="simpara">任意水平空白字符</span></dd>

    
    
     <dt>
<em class="emphasis">\H</em></dt>

     <dd>
<span class="simpara">任意非水平空白字符</span></dd>

    
    
     <dt>
<em class="emphasis">\s</em></dt>

     <dd>
<span class="simpara">任意空白字符</span></dd>

    
    
     <dt>
<em class="emphasis">\S</em></dt>

     <dd>
<span class="simpara">任意非空白字符</span></dd>

    
    
     <dt>
<em class="emphasis">\v</em></dt>

     <dd>
<span class="simpara">任意垂直空白字符</span></dd>

    
    
     <dt>
<em class="emphasis">\V</em></dt>

     <dd>
<span class="simpara">任意非垂直空白字符</span></dd>

    
    
     <dt>
<em class="emphasis">\w</em></dt>

     <dd>
<span class="simpara">任意单词字符</span></dd>

    
    
     <dt>
<em class="emphasis">\W</em></dt>

     <dd>
<span class="simpara">任意非单词字符</span></dd>

    
   </dl>

  </p>
  <p class="para">
  上面每一对转义序列都代表了完整字符集中两个不相交的部分，
  任意字符一定会匹配其中一个，同时一定不会匹配另外一个。
  </p>
  <p class="para">
   &quot;空白字符&quot;（whitespace）是 HT (9)、LF (10)、FF (12)、CR (13)、space (32)。
   然而，若发生了本地化匹配，在代码点 128-255 范围内亦可能出现空白字符，
   比如说 NBSP (A0)。
  </p>
  <p class="para">
  单词字符指的是任意字母、数字、下划线。
  也就是说任意可以组成perl<em class="emphasis">单词</em>的字符。
  字母和数字的定义通过PCRE字符表控制，可以通过指定地域设置使其匹配改变。比如，
  在法国 (fr) 本地化设置中，一些超过 128 的字符代码被用于重音字母，
  它们可以实用 <code class="literal">\w</code> 匹配。
  </p>
  <p class="para">
  这些字符类序列在字符类内部或外部都可以出现。
  他们每次匹配所代表的字符类型中的一个字符。 如果当前匹配点位于目标字符串末尾，
  它们中的所有字符都匹配失败， 因为没有字符让它们匹配了。
  </p>
  <p class="para">
  反斜线的第四种用法是一些简单的断言。
  一个断言指定一个必须在特定位置匹配的条件，
  它们不会从目标字符串中消耗任何字符。
  接下来我们会讨论使用子组的更加复杂的断言。 反斜线断言包括：
  </p>
  <p class="para">
   <dl>
    
     <dt>
<em class="emphasis">\b</em></dt>

     <dd>
<span class="simpara">单词边界</span></dd>

    
    
     <dt>
<em class="emphasis">\B</em></dt>

     <dd>
<span class="simpara">非单词边界</span></dd>

    
    
     <dt>
<em class="emphasis">\A</em></dt>

     <dd>
<span class="simpara">目标的开始位置(独立于多行模式)</span></dd>

    
    
     <dt>
<em class="emphasis">\Z</em></dt>

     <dd>

      <span class="simpara">
      目标的结束位置或结束处的换行符(独立于多行模式)
      </span>
     </dd>

    
    
     <dt>
<em class="emphasis">\z</em></dt>

     <dd>
<span class="simpara">目标的结束位置(独立于多行模式)</span></dd>

    
    
     <dt>
<em class="emphasis">\G</em></dt>

     <dd>
<span class="simpara">在目标中首次匹配位置</span></dd>

    
   </dl>

  </p>
  <p class="para">
  这些断言不能出现在字符类中(但是注意， "<code class="literal">\b</code>"在字符类中有不同的意义，
  表示的是退格(backspace)字符)
  </p>
  <p class="para">
  一个单词边界表示的是在目标字符串中，
  当前字符和前一个字符不同时匹配<code class="literal">\w</code>或<code class="literal">\W</code>(一个匹配<code class="literal">\w</code>,
  一个匹配<code class="literal">\W</code>)，
  或者作为字符串开始或结尾字符的时候当前字符匹配<code class="literal">\w</code>。
  </p>
  <p class="para">
  <code class="literal">\A</code>， <code class="literal">\Z</code>，
  <code class="literal">\z</code>断言不同于传统的<code class="literal">^</code>和<code class="literal">$</code>(详见 <a href="regexp.reference.anchors.html" class="link">锚</a>)，
  因为他们永远匹配目标字符串的开始和结尾，而不会受模式修饰符的限制。
  它们不受<a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_MULTILINE</a>，<a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_DOLLAR_ENDONLY</a>选项的影响。
  <code class="literal">\Z</code> 和 <code class="literal">\z</code> 之间的不同在于当字符串结束字符时换行符时 <code class="literal">\Z</code> 会将其看做字符串结尾匹配,
  而 <code class="literal">\z</code> 只匹配字符串结尾。
  </p>
  <p class="para">
  <code class="literal">\G</code> 断言在指定了<code class="parameter">offset</code> 参数的<span class="function"><a href="function.preg-match.html" class="function">preg_match()</a></span> 调用中，
  仅在当前匹配位置在匹配开始点的时候才是成功的。
  当 <code class="parameter">offset</code> 的值不为 0 的时候，
  它与 <code class="literal">\A</code> 是不同的。 译注：另外一点与 <code class="literal">\A</code> 的不同之处在于使用 preg_match_all() 时，
  每次匹配 <code class="literal">\G</code> 只是断言是否是匹配结果的开始位置，
  而 <code class="literal">\A</code> 断言的则是匹配结果的开始位置是否在目标字符串开始位置。
  </p>
  
  <p class="para">
   <code class="literal">\Q</code> 和 <code class="literal">\E</code> 可以用于在模式中忽略正则表达式元字符。比如：<code class="literal">\w+\Q.$.\E$</code>
   会匹配一个或多个单词字符，紧接着 <code class="literal">.$.</code>，最后锚向字符串末尾。注意这不会改变分隔符的行为；例如模式
   <code class="literal">#\Q#\E#$</code> 无效，因为第二个 <code class="literal">#</code>
   标记了模式的结束，而 <code class="literal">\E#</code> 解释为无效的修饰符。
  </p>
  
  <p class="para">
   <code class="literal">\K</code> 可以用于重置匹配。 比如，
   <code class="literal">foot\Kbar</code> 匹配"footbar"。
  但是得到的匹配结果是 "bar"。但是， <code class="literal">\K</code> 的使用不会干预到子组内的内容，
  比如 <code class="literal">(foot)\Kbar</code> 匹配 "footbar"，第一个子组内的结果仍然会是 "foo"。译注：
  \K 放在子组和子组外面的效果是一样的。
  </p>
  
 </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="124209""></a>
  <div class="note">
   <strong class="user">tharabar at gmail dot com</strong>
   <a href="#124209" class="date">19-Sep-2019 04:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Required to use \007 instead of \a</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="124071""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#124071" class="date">25-Jul-2019 03:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A non breaking space is not considered as a space and cannot be caught by \s.<br />
<br />
it can be found with : <br />
<br />
- [\xc2\xa0] in utf-8<br />
- \x{00a0} in unicode</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="122423""></a>
  <div class="note">
   <strong class="user">Wirek</strong>
   <a href="#122423" class="date">22-Feb-2018 01:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Significantly updated version (with new $pat4 utilising \R properly, its results and comments):<br />
Note that there are (sometimes difficult to grasp at first glance) nuances of meaning and application of escape sequences like \r, \R and \v - none of them is perfect in all situations, but they are quite useful nevertheless. Some official PCRE control options and their changes come in handy too - unfortunately neither (*ANYCRLF), (*ANY) nor (*CRLF) is documented here on php.net at the moment (although they seem to be available for over 10 years and 5 months now), but they are described on Wikipedia ("Newline/linebreak options" at https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions) and official PCRE library site ("Newline convention" at <a href="http://www.pcre.org/original/doc/html/pcresyntax.html#SEC17" rel="nofollow" target="_blank">http://www.pcre.org/original/doc/html/pcresyntax.html#SEC17</a>) pretty well. The functionality of \R appears somehow disappointing (with default configuration of compile time option) according to php.net as well as official description ("Newline sequences" at https://www.pcre.org/original/doc/html/pcrepattern.html#newlineseq) when used improperly.<br />
A hint for those of you who are trying to fight off (or work around at least) the problem of matching a pattern correctly at the end ($) of any line in multiple lines mode (/m).<br />
<span class="default">&lt;?php <br />
</span><span class="comment">// Various OS-es have various end line (a.k.a line break) chars:<br />
// - Windows uses CR+LF (\r\n);<br />
// - Linux LF (\n);<br />
// - OSX CR (\r).<br />
// And that's why single dollar meta assertion ($) sometimes fails with multiline modifier (/m) mode - possible bug in PHP 5.3.8 or just a "feature"(?).<br />
</span><span class="default">$str</span><span class="keyword">=</span><span class="string">"ABC ABC\n\n123 123\r\ndef def\rnop nop\r\n890 890\nQRS QRS\r\r~-_ ~-_"</span><span class="keyword">;<br />
</span><span class="comment">//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; p&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; _<br />
</span><span class="default">$pat1</span><span class="keyword">=</span><span class="string">'/\w$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// This works excellent in JavaScript (Firefox 7.0.1+)<br />
</span><span class="default">$pat2</span><span class="keyword">=</span><span class="string">'/\w\r?$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Slightly better<br />
</span><span class="default">$pat3</span><span class="keyword">=</span><span class="string">'/\w\R?$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Somehow disappointing according to php.net and pcre.org when used improperly<br />
</span><span class="default">$pat4</span><span class="keyword">=</span><span class="string">'/\w(?=\R)/i'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Much better with allowed lookahead assertion (just to detect without capture) without multiline (/m) mode; note that with alternative for end of string ((?=\R|$)) it would grab all 7 elements as expected<br />
</span><span class="default">$pat5</span><span class="keyword">=</span><span class="string">'/\w\v?$/mi'</span><span class="keyword">;<br />
</span><span class="default">$pat6</span><span class="keyword">=</span><span class="string">'/(*ANYCRLF)\w$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Excellent but undocumented on php.net at the moment (described on pcre.org and en.wikipedia.org)<br />
</span><span class="default">$n</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat1</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m1</span><span class="keyword">);<br />
</span><span class="default">$o</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat2</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m2</span><span class="keyword">);<br />
</span><span class="default">$p</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat3</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m3</span><span class="keyword">);<br />
</span><span class="default">$r</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat4</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m4</span><span class="keyword">);<br />
</span><span class="default">$s</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat5</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m5</span><span class="keyword">);<br />
</span><span class="default">$t</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat6</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m6</span><span class="keyword">);<br />
echo </span><span class="default">$str</span><span class="keyword">.</span><span class="string">"\n1 !!! </span><span class="default">$pat1</span><span class="string"> (</span><span class="default">$n</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m1</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n2 !!! </span><span class="default">$pat2</span><span class="string"> (</span><span class="default">$o</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m2</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n3 !!! </span><span class="default">$pat3</span><span class="string"> (</span><span class="default">$p</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m3</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n4 !!! </span><span class="default">$pat4</span><span class="string"> (</span><span class="default">$r</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m4</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n5 !!! </span><span class="default">$pat5</span><span class="string"> (</span><span class="default">$s</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m5</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n6 !!! </span><span class="default">$pat6</span><span class="string"> (</span><span class="default">$t</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m6</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">);<br />
</span><span class="comment">// Note the difference among the three very helpful escape sequences in $pat2 (\r), $pat3 and $pat4 (\R), $pat5 (\v) and altered newline option in $pat6 ((*ANYCRLF)) - for some applications at least.<br />
<br />
/* The code above results in the following output:<br />
ABC ABC<br />
<br />
123 123<br />
def def<br />
nop nop<br />
890 890<br />
QRS QRS<br />
<br />
~-_ ~-_<br />
1 !!! /\w$/mi (3): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; _<br />
)<br />
<br />
2 !!! /\w\r?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
)<br />
<br />
3 !!! /\w\R?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
)<br />
<br />
4 !!! /\w(?=\R)/i (6): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; f<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [5] =&gt; S<br />
)<br />
<br />
5 !!! /\w\v?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
)<br />
<br />
6 !!! /(*ANYCRLF)\w$/mi (7): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; f<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [5] =&gt; S<br />
&nbsp;&nbsp;&nbsp; [6] =&gt; _<br />
)<br />
&nbsp;*/<br />
</span><span class="default">?&gt;<br />
</span>Unfortunately, I haven't got any access to a server with the latest PHP version - my local PHP is 5.3.8 and my public host's PHP is version 5.2.17.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="122412""></a>
  <div class="note">
   <strong class="user">Wirek</strong>
   <a href="#122412" class="date">20-Feb-2018 12:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that there are (sometimes difficult to grasp at first glance) nuances of meaning and application of escape sequences like \r, \R and \v - none of them is perfect in all situations, but they are quite useful nevertheless. Some official PCRE control options and their changes come in handy too - unfortunately neither (*ANYCRLF), (*ANY) nor (*CRLF) is documented here on php.net at the moment (although they seem to be available for over 10 years and 5 months now), but they are described on Wikipedia ("Newline/linebreak options" at https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions) and official PCRE library site ("Newline convention" at <a href="http://www.pcre.org/original/doc/html/pcresyntax.html#SEC17" rel="nofollow" target="_blank">http://www.pcre.org/original/doc/html/pcresyntax.html#SEC17</a>) pretty well. The functionality of \R appears somehow disappointing (with default configuration of compile time option) according to php.net as well as official description ("Newline sequences" at https://www.pcre.org/original/doc/html/pcrepattern.html#newlineseq).<br />
<br />
A hint for those of you who are trying to fight off (or work around at least) the problem of matching a pattern correctly at the end ($) of any line in multiple lines mode (/m).<br />
<span class="default">&lt;?php <br />
</span><span class="comment">// Various OS-es have various end line (a.k.a line break) chars:<br />
// - Windows uses CR+LF (\r\n);<br />
// - Linux LF (\n);<br />
// - OSX CR (\r).<br />
// And that's why single dollar meta assertion ($) sometimes fails with multiline modifier (/m) mode - possible bug in PHP 5.3.8 or just a "feature"(?).<br />
</span><span class="default">$str</span><span class="keyword">=</span><span class="string">"ABC ABC\n\n123 123\r\ndef def\rnop nop\r\n890 890\nQRS QRS\r\r~-_ ~-_"</span><span class="keyword">;<br />
</span><span class="comment">//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; p&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; _<br />
</span><span class="default">$pat1</span><span class="keyword">=</span><span class="string">'/\w$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// This works excellent in JavaScript (Firefox 7.0.1+)<br />
</span><span class="default">$pat2</span><span class="keyword">=</span><span class="string">'/\w\r?$/mi'</span><span class="keyword">;<br />
</span><span class="default">$pat3</span><span class="keyword">=</span><span class="string">'/\w\R?$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Somehow disappointing according to php.net and pcre.org<br />
</span><span class="default">$pat4</span><span class="keyword">=</span><span class="string">'/\w\v?$/mi'</span><span class="keyword">;<br />
</span><span class="default">$pat5</span><span class="keyword">=</span><span class="string">'/(*ANYCRLF)\w$/mi'</span><span class="keyword">;&nbsp; &nbsp; </span><span class="comment">// Excellent but undocumented on php.net at the moment<br />
</span><span class="default">$n</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat1</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m1</span><span class="keyword">);<br />
</span><span class="default">$o</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat2</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m2</span><span class="keyword">);<br />
</span><span class="default">$p</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat3</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m3</span><span class="keyword">);<br />
</span><span class="default">$r</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat4</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m4</span><span class="keyword">);<br />
</span><span class="default">$s</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pat5</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">, </span><span class="default">$m5</span><span class="keyword">);<br />
echo </span><span class="default">$str</span><span class="keyword">.</span><span class="string">"\n1 !!! </span><span class="default">$pat1</span><span class="string"> (</span><span class="default">$n</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m1</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n2 !!! </span><span class="default">$pat2</span><span class="string"> (</span><span class="default">$o</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m2</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n3 !!! </span><span class="default">$pat3</span><span class="string"> (</span><span class="default">$p</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m3</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n4 !!! </span><span class="default">$pat4</span><span class="string"> (</span><span class="default">$r</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m4</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; .</span><span class="string">"\n5 !!! </span><span class="default">$pat5</span><span class="string"> (</span><span class="default">$s</span><span class="string">): "</span><span class="keyword">.</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$m5</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">true</span><span class="keyword">);<br />
</span><span class="comment">// Note the difference among the three very helpful escape sequences in $pat2 (\r), $pat3 (\R), $pat4 (\v) and altered newline option in $pat5 ((*ANYCRLF)) - for some applications at least.<br />
<br />
/* The code above results in the following output:<br />
ABC ABC<br />
<br />
123 123<br />
def def<br />
nop nop<br />
890 890<br />
QRS QRS<br />
<br />
~-_ ~-_<br />
1 !!! /\w$/mi (3): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; _<br />
)<br />
<br />
2 !!! /\w\r?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
)<br />
<br />
3 !!! /\w\R?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
) <br />
<br />
4 !!! /\w\v?$/mi (5): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; _<br />
)<br />
<br />
5 !!! /(*ANYCRLF)\w$/mi (7): Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; C<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 3<br />
&nbsp;&nbsp;&nbsp; [2] =&gt; f<br />
&nbsp;&nbsp;&nbsp; [3] =&gt; p<br />
&nbsp;&nbsp;&nbsp; [4] =&gt; 0<br />
&nbsp;&nbsp;&nbsp; [5] =&gt; S<br />
&nbsp;&nbsp;&nbsp; [6] =&gt; _<br />
)<br />
&nbsp;*/<br />
</span><span class="default">?&gt;<br />
</span>Unfortunately, I haven't got any access to a server with the latest PHP version - my local PHP is 5.3.8 and my public host's PHP is version 5.2.17.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="121363""></a>
  <div class="note">
   <strong class="user">vea dot git at gmail dot com</strong>
   <a href="#121363" class="date">12-Jul-2017 03:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
\b BS<br />
<br />
$str=""<br />
<br />
$str =str_replace("\b", "", $str);<br />
//echo <br />
<br />
$str =str_replace(chr(8), "", $str);<br />
//echo <br />
<br />
$str =str_replace("\\b", "", $str);<br />
//echo</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="118026""></a>
  <div class="note">
   <strong class="user">error17191 at gmail dot com</strong>
   <a href="#118026" class="date">21-Sep-2015 12:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Some escape sequence like the tab character \t won't work inside single quotes '\t', But they work inside double quotes.<br />
Other escape sequences like the backspace character won't work unless you use its ascii codepoint and chr() function i.e. chr(8)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115224""></a>
  <div class="note">
   <strong class="user">info at maisuma dot jp</strong>
   <a href="#115224" class="date">17-Jun-2014 04:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can use Unicode character escape sequences (tested on PHP 5.3.3 &amp; PCRE 7.8).<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">//This source is supposed to be written in UTF-8.<br />
</span><span class="default">$a</span><span class="keyword">=</span><span class="string">'€'</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/\\x{20ac}/u'</span><span class="keyword">,</span><span class="default">$a</span><span class="keyword">)); </span><span class="comment">//Match!</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114130""></a>
  <div class="note">
   <strong class="user">bluemoehre at gmx dot de</strong>
   <a href="#114130" class="date">14-Jan-2014 12:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using \R in character classes is NOT possible:<br />
<br />
var_dump( preg_match('#\R+#',"\n") ); -&gt; int(1)<br />
var_dump( preg_match('#[\R]+#',"\n") ); -&gt; int(0)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113388""></a>
  <div class="note">
   <strong class="user">collons at ya dot com</strong>
   <a href="#113388" class="date">04-Oct-2013 04:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The pattern "/\\A/" may be replaced by "/\\\A/" in order to match a "\A" string. Any other escaped "\" looks to work fine so you can use "/\\S/", for instance, to match a "\S" string.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="108096""></a>
  <div class="note">
   <strong class="user">mike at eastghost dot com</strong>
   <a href="#108096" class="date">28-Mar-2012 07:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
"line break" is ill-defined:<br />
<br />
&nbsp;-- Windows uses CR+LF (\r\n)<br />
&nbsp;-- Linux LF (\n)<br />
&nbsp;-- OSX CR (\r)<br />
<br />
Little-known special character:<br />
\R in preg_* matches all three.<br />
<br />
preg_match( '/^\R$/', "match\nany\\n\rline\r\nending\r" ); // match any line endings</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="104553""></a>
  <div class="note">
   <strong class="user">grigor at the domain gatchev.info</strong>
   <a href="#104553" class="date">22-Jun-2011 01:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As \v matches both single char line ends (CR, LF) and double char (CR+LF, LF+CR), it is not a fixed length atom (eg. is not allowed in lookbehind assertions).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
