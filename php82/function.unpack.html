<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=UTF-8">
  <title>Unpack data from binary string</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.uniqid.html">? uniqid</a></li>
      <li style="float: right;"><a href="function.usleep.html">usleep ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.misc.html">杂项 函数</a></li>
    <li>Unpack data from binary string</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.unpack" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">unpack</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">unpack</span> &mdash; <span class="dc-title">Unpack data from binary string</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.unpack-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>unpack</strong></span>(<span class="methodparam"><span class="type">string</span> <code class="parameter">$format</code></span>, <span class="methodparam"><span class="type">string</span> <code class="parameter">$string</code></span>, <span class="methodparam"><span class="type">int</span> <code class="parameter">$offset</code><span class="initializer"> = 0</span></span>): <span class="type"><span class="type">array</span>|<span class="type"><span class="type false">false</span></span></span></div>

  <p class="para rdfs-comment">
   Unpacks from a binary string into an array according to the given
   <code class="parameter">format</code>. 
  </p>
  <p class="para">
   The unpacked data is stored in an associative array. To
   accomplish this you have to name the different format codes and
   separate them by a slash /. If a repeater argument is present,
   then each of the array keys will have a sequence number behind
   the given name.
  </p>
  <p class="para">
   Changes were made to bring this function into line with Perl:
   <ul class="simplelist">
    <li class="member">
     The &quot;a&quot; code now retains trailing NULL bytes.
    </li>
    <li class="member">
     The &quot;A&quot; code now strips all trailing ASCII whitespace (spaces, tabs,
     newlines, carriage returns, and NULL bytes).
    </li>
    <li class="member">
     The &quot;Z&quot; code was added for NULL-padded strings, and removes trailing
     NULL bytes.
    </li>
   </ul>
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.unpack-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>
    
     <dt>
<code class="parameter">format</code></dt>

     <dd>

      <p class="para">
       See <span class="function"><a href="function.pack.html" class="function">pack()</a></span> for an explanation of the format codes.
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">string</code></dt>

     <dd>

      <p class="para">
       The packed data.
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">offset</code></dt>

     <dd>

      <p class="para">
       The offset to begin unpacking from.
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.unpack-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   Returns an associative array containing unpacked elements of binary
   string,  或者在失败时返回 <strong><code>false</code></strong>.
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.unpack-changelog">
  <h3 class="title">更新日志</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>版本</th>
       <th>说明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>7.2.0</td>
       <td>
        <span class="type">float</span> and <span class="type">double</span> types supports both Big Endian and Little Endian.
       </td>
      </tr>

      <tr>
       <td>7.1.0</td>
       <td>
        The optional <code class="parameter">offset</code> has been added.
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.unpack-examples">
  <h3 class="title">示例</h3>
  <p class="para">
   <div class="example" id="">
    <p><strong>Example #1 <span class="function"><strong>unpack()</strong></span> example</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata </span><span style="color: #007700">= </span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array </span><span style="color: #007700">= </span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"cchars/nint"</span><span style="color: #007700">, </span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上示例会输出：</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
Array
(
    [chars] =&gt; 4
    [int] =&gt; 160
)
</pre></div>
    </div>
   </div>
  </p>

  <p class="para">
   <div class="example" id="">
    <p><strong>Example #2 <span class="function"><strong>unpack()</strong></span> example with a repeater</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata </span><span style="color: #007700">= </span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array </span><span style="color: #007700">= </span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2chars/nint"</span><span style="color: #007700">, </span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>以上示例会输出：</p></div>
     <div class="example-contents screen">
<div class="cdata"><pre>
Array
(
    [chars1] =&gt; 4
    [chars2] =&gt; 0
    [int] =&gt; 40960
)
</pre></div>
     </div>
    </div>
   </p>
  </div>


 <div class="refsect1 notes" id="refsect1-function.unpack-notes">
  <h3 class="title">注释</h3>
  <div class="caution"><strong class="caution">Caution</strong>
   <p class="para">
    Note that PHP internally stores integral values as signed. If you
    unpack a large unsigned long and it is of the same size as PHP
    internally stored values the result will be a negative number
    even though unsigned unpacking was specified.
   </p>
  </div>
  <div class="caution"><strong class="caution">Caution</strong>
   <p class="para">
    If you do not name an element, numeric indices starting from <code class="literal">1</code> are used.
    Be aware that if you have more than one unnamed element, some data is
    overwritten because the numbering restarts from <code class="literal">1</code> for each element.
   </p>
   <p class="para">
    <div class="example" id="">
     <p><strong>Example #3 <span class="function"><strong>unpack()</strong></span> example with unnamed keys</strong></p>
     <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata </span><span style="color: #007700">= </span><span style="color: #DD0000">"\x32\x42\x00\xa0"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array </span><span style="color: #007700">= </span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2/n"</span><span style="color: #007700">, </span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>以上示例会输出：</p></div>
     <div class="example-contents screen">
<div class="cdata"><pre>
array(2) {
  [1]=&gt;
  int(160)
  [2]=&gt;
  int(66)
}
</pre></div>
     </div>
     <div class="example-contents"><p>
      Note that the
      first value from the <code class="literal">c</code> specifier is 
      overwritten by the first value from the <code class="literal">n</code>
      specifier.
     </p></div>
    </div>
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.unpack-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.pack.html" class="function" rel="rdfs-seeAlso">pack()</a> - 将数据打包成二进制字符串</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="124664""></a>
  <div class="note">
   <strong class="user">ludwig at kni-online dot de</strong>
   <a href="#124664" class="date">30-Jan-2020 11:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Don't forget to decode user-defined-pseudo-byte-sequences before unpacking...<br />
<span class="default">&lt;?php<br />
&nbsp; $byte_code_string </span><span class="keyword">=&nbsp; </span><span class="string">'00004040'</span><span class="keyword">;<br />
&nbsp; </span><span class="default">var_dump </span><span class="keyword">( </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'f'</span><span class="keyword">, </span><span class="default">$byte_code_string </span><span class="keyword">) );<br />
</span><span class="default">?&gt;<br />
</span>Result:<br />
&nbsp; array(1) {<br />
&nbsp;&nbsp;&nbsp; [1]=&gt;<br />
&nbsp;&nbsp;&nbsp; float(6.4096905560973E-10)<br />
&nbsp; }<br />
<br />
whereas<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp; $byte_code_string </span><span class="keyword">=&nbsp; </span><span class="string">'00004040'</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">var_dump </span><span class="keyword">( </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'f'</span><span class="keyword">, </span><span class="default">hex2bin </span><span class="keyword">( </span><span class="default">$byte_code_string </span><span class="keyword">) ) );<br />
</span><span class="default">?&gt;<br />
</span>Result:<br />
&nbsp; array(1) {<br />
&nbsp;&nbsp;&nbsp; [1]=&gt;<br />
&nbsp;&nbsp;&nbsp; float(3)<br />
&nbsp; }</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="119403""></a>
  <div class="note">
   <strong class="user">stanislav dot eckert at vizson dot de</strong>
   <a href="#119403" class="date">29-May-2016 03:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A helper class to convert integer to binary strings and vice versa. Useful for writing and reading integers to / from files or sockets.<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">class </span><span class="default">int_helper<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">int8</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"c"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"c"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">uInt8</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"C"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">int16</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"s"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"s"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">uInt16</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">, </span><span class="default">$endianness</span><span class="keyword">=</span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="string">"pack" </span><span class="keyword">: </span><span class="string">"unpack"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">true</span><span class="keyword">) {&nbsp; </span><span class="comment">// big-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"n"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">false</span><span class="keyword">) {&nbsp; </span><span class="comment">// little-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"v"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">null</span><span class="keyword">) {&nbsp; </span><span class="comment">// machine byte order<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"S"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">$i</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] : </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">int32</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"l"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"l"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">uInt32</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">, </span><span class="default">$endianness</span><span class="keyword">=</span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="string">"pack" </span><span class="keyword">: </span><span class="string">"unpack"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">true</span><span class="keyword">) {&nbsp; </span><span class="comment">// big-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"N"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">false</span><span class="keyword">) {&nbsp; </span><span class="comment">// little-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"V"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">null</span><span class="keyword">) {&nbsp; </span><span class="comment">// machine byte order<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">$i</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] : </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">int64</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"q"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"q"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">uInt64</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">, </span><span class="default">$endianness</span><span class="keyword">=</span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="string">"pack" </span><span class="keyword">: </span><span class="string">"unpack"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">true</span><span class="keyword">) {&nbsp; </span><span class="comment">// big-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"J"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">false</span><span class="keyword">) {&nbsp; </span><span class="comment">// little-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"P"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">null</span><span class="keyword">) {&nbsp; </span><span class="comment">// machine byte order<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"Q"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">$i</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] : </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
Usage example:<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; Header</span><span class="keyword">(</span><span class="string">"Content-Type: text/plain"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; include(</span><span class="string">"int_helper.php"</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt8</span><span class="keyword">(</span><span class="default">0x6b</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// k<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt8</span><span class="keyword">(</span><span class="default">107</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// k<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt8</span><span class="keyword">(</span><span class="string">"\x6b"</span><span class="keyword">) . </span><span class="default">PHP_EOL </span><span class="keyword">. </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 107<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt16</span><span class="keyword">(</span><span class="default">4101</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// \x05\x10<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt16</span><span class="keyword">(</span><span class="string">"\x05\x10"</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 4101<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt16</span><span class="keyword">(</span><span class="string">"\x05\x10"</span><span class="keyword">, </span><span class="default">true</span><span class="keyword">) . </span><span class="default">PHP_EOL </span><span class="keyword">. </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 1296<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt32</span><span class="keyword">(</span><span class="default">2147483647</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// \xff\xff\xff\x7f<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt32</span><span class="keyword">(</span><span class="string">"\xff\xff\xff\x7f"</span><span class="keyword">) . </span><span class="default">PHP_EOL </span><span class="keyword">. </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 2147483647<br />
<br />
&nbsp;&nbsp;&nbsp; // Note: Test this with 64-bit build of PHP<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt64</span><span class="keyword">(</span><span class="default">9223372036854775807</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// \xff\xff\xff\xff\xff\xff\xff\x7f<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt64</span><span class="keyword">(</span><span class="string">"\xff\xff\xff\xff\xff\xff\xff\x7f"</span><span class="keyword">) . </span><span class="default">PHP_EOL </span><span class="keyword">. </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 9223372036854775807<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="110102""></a>
  <div class="note">
   <strong class="user">googlybash24 at aol dot com</strong>
   <a href="#110102" class="date">19-Sep-2012 05:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To convert big endian to little endian or to convert little endian to big endian, use the following approach as an example:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// file_get_contents() returns a binary value, unpack("V*", _ ) returns an unsigned long 32-bit little endian decimal value, but bin2hex() after that would just give the hex data in the file if alone, so instead we use:<br />
// file_get_contents(), unpack("V*", _ ), then dechex(), in that order, to get the byte-swapping effect.<br />
</span><span class="default">?&gt;<br />
</span><br />
With the logic of the approach in this example, you can discover how to swap the endian byte order as you need.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="106041""></a>
  <div class="note">
   <strong class="user">rogier</strong>
   <a href="#106041" class="date">05-Oct-2011 07:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
be aware of the behavior of your system that PHP resides on.
<br />

<br />
On x86, unpack MAY not yield the result you expect for UInt32
<br />

<br />
This is due to the internal nature of PHP, being that integers are internally stored as SIGNED!
<br />

<br />
For x86 systems, unpack('N', "\xff\xff\xff\xff") results in -1
<br />
For (most?) x64 systems, unpack('N', "\xff\xff\xff\xff") results in 4294967295.
<br />

<br />
This can be verified by checking the value of PHP_INT_SIZE.
<br />
If this value is 4, you have a PHP that internally stores 32-bit.
<br />
A value of 8 internally stores 64-bit.
<br />

<br />
To work around this 'problem', you can use the following code to avoid problems with unpack.
<br />
The code is for big endian order but can easily be adjusted for little endian order (also, similar code works for 64-bit integers):
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">_uint32be</span><span class="keyword">(</span><span class="default">$bin</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// $bin is the binary 32-bit BE string that represents the integer
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">PHP_INT_SIZE </span><span class="keyword">&lt;= </span><span class="default">4</span><span class="keyword">){
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list(,</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$l</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'n*'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return (</span><span class="default">$l </span><span class="keyword">+ (</span><span class="default">$h</span><span class="keyword">*</span><span class="default">0x010000</span><span class="keyword">));
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; else{
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list(,</span><span class="default">$int</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$int</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; }
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
Do note that you *could* also use sprintf('%u', $x) to show the unsigned real value.
<br />
Also note that (at least when PHP_INT_SIZE = 4) the result WILL be a float value when the input is larger then 0x7fffffff (just check with gettype);
<br />

<br />
Hope this helps people.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100326""></a>
  <div class="note">
   <strong class="user">Aaron Wells</strong>
   <a href="#100326" class="date">08-Oct-2010 03:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another option for converting binary data into PHP data types, is to use the Zend Framework's Zend_Io_Reader class:<br />
<a href="http://bit.ly/9zAhgz" rel="nofollow" target="_blank">http://bit.ly/9zAhgz</a><br />
<br />
There's also a Zend_Io_Writer class that does the reverse.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="97177""></a>
  <div class="note">
   <strong class="user">norwood at computer dot org</strong>
   <a href="#97177" class="date">06-Apr-2010 02:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Reading a text cell from an Excel spreadsheet returned a string with low-order embedded nulls: 0x4100 0x4200 etc. To remove the nulls, used
<br />

<br />
<span class="default">&lt;?php
<br />
$strWithoutNulls </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">( </span><span class="string">''</span><span class="keyword">, </span><span class="default">explode</span><span class="keyword">( </span><span class="string">"\0"</span><span class="keyword">, </span><span class="default">$strWithNulls </span><span class="keyword">) );
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
(unpack() didn't seem to help much here; needed chars back to re-constitute the string, not integers.)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93714""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#93714" class="date">23-Sep-2009 08:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Functions I found useful when dealing with fixed width file processing, related to unpack/pack functions.<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/**<br />
* funpack<br />
* format: array of key, length pairs<br />
* data: string to unpack<br />
*/<br />
</span><span class="keyword">function </span><span class="default">funpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">trim</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos</span><span class="keyword">+= </span><span class="default">$len</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$result</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">/**<br />
* fpack<br />
* format: array of key, length pairs<br />
* data: array of key, value pairs to pack<br />
* pad: padding direction<br />
*/<br />
</span><span class="keyword">function </span><span class="default">fpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pad </span><span class="keyword">= </span><span class="default">STR_PAD_RIGHT</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result </span><span class="keyword">.= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">str_pad</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">], </span><span class="default">$len</span><span class="keyword">, </span><span class="default">$pad</span><span class="keyword">), </span><span class="default">0</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$result</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92344""></a>
  <div class="note">
   <strong class="user">sica at wnet com br</strong>
   <a href="#92344" class="date">20-Jul-2009 12:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The script following is a example how to save more than one values on file separating its with "\r\n" and how to recovering its values.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// Save two integer values in a binary file<br />
</span><span class="default">$nomearq </span><span class="keyword">= </span><span class="string">"./teste.bin"</span><span class="keyword">;<br />
</span><span class="default">$valor </span><span class="keyword">= </span><span class="default">123</span><span class="keyword">;<br />
</span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"wb"</span><span class="keyword">);<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
echo </span><span class="string">"First value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
echo </span><span class="string">"Separator \\r\\n with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="string">"\r\n"</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
</span><span class="default">$valor </span><span class="keyword">= </span><span class="default">456</span><span class="keyword">;<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
echo </span><span class="string">"Second value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br />
<br />
</span><span class="comment">// Recover the saved values<br />
</span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"rb"</span><span class="keyword">);<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">file</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">,</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">));<br />
echo </span><span class="string">"&lt;br&gt;The reading values is:&lt;br&gt;"</span><span class="keyword">;<br />
foreach(</span><span class="default">$valorBin </span><span class="keyword">as </span><span class="default">$valor</span><span class="keyword">){<br />
&nbsp; </span><span class="default">$valor </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$valor</span><span class="keyword">);<br />
&nbsp; echo </span><span class="string">"&lt;br&gt;"</span><span class="keyword">;<br />
}<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Results:<br />
First value (123) packed with 4 bytes<br />
Separator \r\n with 2 bytes<br />
Second value (456) packed with 4 bytes<br />
<br />
The reading values is:<br />
Array ( [1] =&gt; 123 ) <br />
Array ( [1] =&gt; 456 )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82146""></a>
  <div class="note">
   <strong class="user">Anonymous Coward</strong>
   <a href="#82146" class="date">28-Mar-2008 10:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Warning: This unpack function makes the array with keys starting at 1 instead of starting at 0.<br />
<br />
For example:<br />
<span class="default">&lt;?php<br />
&nbsp;</span><span class="keyword">function </span><span class="default">read_field</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$a</span><span class="keyword">=</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V"</span><span class="keyword">,</span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">4</span><span class="keyword">));<br />
&nbsp; return </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br />
&nbsp;}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46725""></a>
  <div class="note">
   <strong class="user">jjfoerch at earthlink dot net</strong>
   <a href="#46725" class="date">21-Oct-2004 04:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had a situation where I had to unpack a file filled with little-endian order double-floats in a way that would work on either little-endian or big-endian machines.&nbsp; PHP doesn't have a formatting code that will change the byte order of doubles, so I wrote this workaround.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/*The following code is a workaround for php's unpack function<br />
which does not have the capability of unpacking double precision<br />
floats that were packed in the opposite byte order of the current<br />
machine.<br />
*/<br />
</span><span class="keyword">function </span><span class="default">big_endian_unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ar </span><span class="keyword">= </span><span class="default">unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$vals </span><span class="keyword">= </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">explode </span><span class="keyword">(</span><span class="string">'/'</span><span class="keyword">, </span><span class="default">$format</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$f </span><span class="keyword">as </span><span class="default">$f_k </span><span class="keyword">=&gt; </span><span class="default">$f_v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">intval </span><span class="keyword">(</span><span class="default">substr </span><span class="keyword">(</span><span class="default">$f_v</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$repeater </span><span class="keyword">== </span><span class="default">0</span><span class="keyword">) </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">1</span><span class="keyword">} == </span><span class="string">'*'</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">count </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">) - </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">0</span><span class="keyword">} != </span><span class="string">'d'</span><span class="keyword">) { </span><span class="default">$i </span><span class="keyword">+= </span><span class="default">$repeater</span><span class="keyword">; continue; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$j </span><span class="keyword">= </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">$repeater</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$a </span><span class="keyword">= </span><span class="default">$i</span><span class="keyword">; </span><span class="default">$a </span><span class="keyword">&lt; </span><span class="default">$j</span><span class="keyword">; ++</span><span class="default">$a</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'d'</span><span class="keyword">,</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">strrev </span><span class="keyword">(</span><span class="default">$p</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list (</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'d1d'</span><span class="keyword">, </span><span class="default">$p</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ++</span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$ar </span><span class="keyword">as </span><span class="default">$ar_k </span><span class="keyword">=&gt; </span><span class="default">$ar_v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ar</span><span class="keyword">[</span><span class="default">$ar_k</span><span class="keyword">] = </span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$a</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; ++</span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$ar</span><span class="keyword">;<br />
}<br />
<br />
list (</span><span class="default">$endiantest</span><span class="keyword">) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'L1L'</span><span class="keyword">, </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'V'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">)));<br />
if (</span><span class="default">$endiantest </span><span class="keyword">!= </span><span class="default">1</span><span class="keyword">) </span><span class="default">define </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">);<br />
if (</span><span class="default">defined </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">)) </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'big_endian_unpack'</span><span class="keyword">;<br />
else </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'unpack'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
This workaround is used like this:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">foo</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; global </span><span class="default">$unpack_workaround</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bar </span><span class="keyword">= </span><span class="default">$unpack_workaround</span><span class="keyword">(</span><span class="string">'N7N/V2V/d8d'</span><span class="keyword">,</span><span class="default">$my_data</span><span class="keyword">);<br />
</span><span class="comment">//...<br />
</span><span class="keyword">}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
On a little endian machine, $unpack_workaround will simply point to the function unpack.&nbsp; On a big endian machine, it will call the workaround function.<br />
<br />
Note, this solution only works for doubles.&nbsp; In my project I had no need to check for single precision floats.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45188""></a>
  <div class="note">
   <strong class="user">kennwhite dot nospam at hotmail dot com</strong>
   <a href="#45188" class="date">28-Aug-2004 12:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If having a zero-based index is useful/necessary, then instead of:<br />
<br />
$int_list = unpack("s*", $some_binary_data);<br />
<br />
&nbsp;try:<br />
<br />
$int_list = array_merge(unpack("s*", $some_binary_data));<br />
<br />
This will return a 0-based array:<br />
<br />
$int_list[0] = x<br />
$int_list[1] = y<br />
$int_list[2] = z<br />
...<br />
<br />
rather than the default 1-based array returned from unpack when no key is supplied:<br />
<br />
$int_list[1] = x<br />
$int_list[2] = y<br />
$int_list[3] = z<br />
...<br />
<br />
It's not used often, but array_merge() with only one parameter will compress a sequentially-ordered numeric-index, starting with an index of [0].</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43945""></a>
  <div class="note">
   <strong class="user">Sergio Santana: ssantana at tlaloc dot imta dot mx</strong>
   <a href="#43945" class="date">09-Jul-2004 10:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is about the last example of my previous post. For the sake of clarity, I'm including again here the example, which expands the one given in the formal documentation:<br />
<br />
&lt;?<br />
&nbsp; $binarydata = "AA\0A";<br />
&nbsp; $array = unpack("c2chars/nint", $binarydata);<br />
&nbsp; foreach ($array as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br />
?&gt;<br />
<br />
This outputs:<br />
<br />
$array[chars1] = 65 <br />
$array[chars2] = 65 <br />
$array[int] = 65 <br />
<br />
Here, we assume that the ascii code for character 'A' is decimal 65.<br />
<br />
Remebering that the format string structure is:<br />
&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...],<br />
in this example, the format string instructs the function to<br />
&nbsp; 1. ("c2...") Read two chars from the second argument ("AA ...), <br />
&nbsp; 2. (...chars...) Use the array-keys "chars1", and "chars2" for <br />
&nbsp;&nbsp; &nbsp;&nbsp; these two chars read,<br />
&nbsp; 3. (.../n...) Read a short int from the second argument (...\0A"),<br />
&nbsp; 4. (...int") Use the word "int" as the array key for the just read<br />
&nbsp;&nbsp; &nbsp;&nbsp; short.<br />
<br />
I hope this is clearer now,<br />
<br />
Sergio.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43930""></a>
  <div class="note">
   <strong class="user">Sergio Santana: ssantana at tlaloc dot imta dot mx</strong>
   <a href="#43930" class="date">08-Jul-2004 07:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Suppose we need to get some kind of internal representation of an integer, say 65, as a four-byte long. Then we use, something like:<br />
<br />
&lt;?<br />
&nbsp; $i = 65;<br />
&nbsp; $s = pack("l", $i); // long 32 bit, machine byte order<br />
&nbsp; echo strlen($s) . "&lt;br&gt;\n";<br />
&nbsp; echo "***$s***&lt;br&gt;\n";<br />
?&gt;<br />
<br />
The output is:<br />
<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
4<br />
***A*** <br />
<br />
(That is the string "A\0\0\0")<br />
<br />
Now we want to go back from string "A\0\0\0" to number 65. In this case we can use:<br />
<br />
&lt;?<br />
&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number 65<br />
&nbsp; $arr = unpack("l", $s);<br />
&nbsp; foreach ($arr as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$arr[$key] = $value&lt;br&gt;\n";<br />
?&gt;<br />
<br />
And this outpus:<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$arr[] = 65<br />
<br />
Let's give the array key a name, say "mykey". In this case, we can use: <br />
<br />
&lt;?<br />
&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number&nbsp; 65<br />
&nbsp; $arr = unpack("lmykey", $s);<br />
&nbsp; foreach ($arr as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$arr[$key] = $value\n";<br />
?&gt;<br />
<br />
An this outpus:<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$arr[mykey] = 65<br />
<br />
The "unpack" documentation is a little bit confusing. I think a more complete example could be:<br />
<br />
&lt;?<br />
&nbsp; $binarydata = "AA\0A";<br />
&nbsp; $array = unpack("c2chars/nint", $binarydata);<br />
&nbsp; foreach ($array as $key =&gt; $value)<br />
&nbsp;&nbsp;&nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br />
?&gt;<br />
<br />
whose output is:<br />
<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$array[chars1] = 65 &lt;br&gt;<br />
$array[chars2] = 65 &lt;br&gt;<br />
$array[int] = 65 &lt;br&gt;<br />
<br />
Note that the format string is something like<br />
&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...]<br />
<br />
I hope this clarifies something<br />
<br />
Sergio</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="4319""></a>
  <div class="note">
   <strong class="user">iredden at redden dot on dot ca</strong>
   <a href="#4319" class="date">11-Mar-2000 04:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php
<br />

<br />
</span><span class="keyword">function </span><span class="default">parse_pascalstr</span><span class="keyword">(</span><span class="default">$bytes_parsed</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">) { 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/cstr_len"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str_len </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str_len"</span><span class="keyword">]; 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">; 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/A"</span><span class="keyword">.</span><span class="default">$str_len</span><span class="keyword">.</span><span class="string">"str"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">); 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str"</span><span class="keyword">]; 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">); 
<br />

<br />
&nbsp;&nbsp;&nbsp; return array(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$bytes_parsed</span><span class="keyword">); 
<br />
}
<br />

<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
